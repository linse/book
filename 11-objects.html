<html class="js flexbox fontface" lang="en" style=""><head><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real World OCaml</title><link rel="stylesheet" href="css/app.css"/><link rel="stylesheet" href="css/prism.css"/><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a href="toc.html" class="to-chapter"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body">
  <section xmlns="http://www.w3.org/1999/xhtml" id="objects" data-type="chapter">
    <h1>Objects</h1>

    <p>
      We've already seen several tools that OCaml provides for
      organizing programs, particularly modules. In addition, OCaml
      also supports object-oriented programming. There are objects,
      classes, and their associated types. In this chapter, we'll
      introduce you to OCaml objects and subtyping. In the next
      chapter, <a href="12-classes.html#classes" data-type="xref">Chapter 12, Classes</a>, we'll introduce you to classes and
      inheritance.

      <a data-type="indexterm" data-primary="objects" data-secondary="in object-oriented programming">&nbsp;</a>
      <a data-type="indexterm" data-primary="object-oriented programming (OOP)">&nbsp;</a>
      <a data-type="indexterm" data-primary="programming" data-secondary="object-oriented programming (OOP)">&nbsp;</a>
    </p>

    <aside data-type="sidebar">
      <h5>What Is Object-Oriented Programming?</h5>

      <p>Object-oriented programming (often shortened to OOP) is a
      programming style that encapsulates computation and data
      within logical <em>objects</em>. Each object contains some
      data stored in <em>fields</em> and has <em>method</em>
      functions that can be invoked against the data within the
      object (also called "sending a message" to the object). The
      code definition behind an object is called a <em>class</em>,
      and objects are constructed from a class definition by
      calling a constructor with the data that the object will use
      to build itself.</p>

      <p>There are five fundamental properties that differentiate
      OOP from other styles:</p>

      <dl>
        <dt>Abstraction</dt>

        <dd>
          <p>The details of the implementation are hidden in the
          object, and the external interface is just the set of
          publicly accessible methods.</p>
        </dd>

        <dt>Dynamic lookup</dt>

        <dd>
          <p>When a message is sent to an object, the method to be
          executed is determined by the implementation of the
          object, not by some static property of the program. In
          other words, different objects may react to the same
          message in different ways.</p>
        </dd>

        <dt>Subtyping</dt>

        <dd>
          <p>If an object <code>a</code> has all the functionality
          of an object <code>b</code>, then we may use
          <code>a</code> in any context where <code>b</code> is
          expected.</p>
        </dd>

        <dt>Inheritance</dt>

        <dd>
          <p>The definition of one kind of object can be reused to
          produce a new kind of object. This new definition can
          override some behavior, but also share code with its
          parent.</p>
        </dd>

        <dt>Open recursion</dt>

        <dd>
          <p>An object's methods can invoke another method in the
          same object using a special variable (often called
          <code>self</code> or <code>this</code>). When objects are
          created from classes, these calls use dynamic lookup,
          allowing a method defined in one class to invoke methods
          defined in another class that inherits from the
          first.</p>
        </dd>
      </dl>

      <p>Almost every notable modern programming language has been
      influenced by OOP, and you'll have run across these terms if
      you've ever used C++, Java, C#, Ruby, Python, or
      JavaScript.</p>
    </aside>

    <section id="ocaml-objects" data-type="sect1">
      <h1>OCaml Objects</h1>

      <p>If you already know about object-oriented programming in a
      language like Java or <span class="keep-together">C++,</span>
      the OCaml object system may come as a surprise. Foremost is
      the complete separation of objects and their types from the
      class system. In a language like Java, a class name is also
      used as the type of objects created by instantiating it, and
      the relationships between these object types correspond to
      inheritance. For example, if we implement a class
      <code>Deque</code> in Java by inheriting from a class
      <code>Stack</code>, we would be allowed to pass a deque
      anywhere a stack is expected.

      <a data-type="indexterm" data-primary="objects" data-secondary="in OCaml">&nbsp;</a>
      </p>

      <p>OCaml is entirely different. Classes are used to construct
      objects and support inheritance, but classes are not types.
      Instead, objects have <em>object types</em>, and if you want
      to use objects, you aren't required to use classes at all.
      Here's an example of a simple object:</p>

      <div class="highlight"><pre><code class="language-ocaml"># open Core_kernel;;</code></pre><pre><code class="language-ocaml"># let s = object
    val mutable v = [0; 2]
  
    method pop =
      match v with
      | hd :: tl -&gt;
        v &lt;- tl;
        Some hd
      | [] -&gt; None
  
    method push hd =
      v &lt;- hd :: v
  end ;;</code></pre><pre class="ge"><code class="language-ocaml">val s : &lt; pop : int option; push : int -&gt; unit &gt; = &lt;obj&gt;</code></pre></div>

      <p>The object has an integer list value <code>v</code>, a
      method <code>pop</code> that returns the head of
      <code>v</code>, and a method <code>push</code> that adds an
      integer to the head of <code>v</code>.</p>

      <p>The object type is enclosed in angle brackets <code>&lt;
      ... &gt;</code>, containing just the types of the methods.
      Fields, like <code>v</code>, are not part of the public
      interface of an object. All interaction with an object is
      through its methods. The syntax for a method invocation uses
      the <code>#</code> character:</p>

      <div class="highlight"><pre><code class="language-ocaml"># s#pop ;;</code></pre><pre class="ge"><code class="language-ocaml">- : int option = Some 0</code></pre><pre><code class="language-ocaml"># s#push 4 ;;</code></pre><pre class="ge"><code class="language-ocaml">- : unit = ()</code></pre><pre><code class="language-ocaml"># s#pop ;;</code></pre><pre class="ge"><code class="language-ocaml">- : int option = Some 4</code></pre></div>

      <p>Note that unlike functions, methods can have zero
      parameters, since the method call is routed to a concrete
      object instance. That's why the <code>pop</code> method
      doesn't have a <code>unit</code> argument, as the equivalent
      functional version would.</p>

      <p>Objects can also be constructed by functions. If we want
      to specify the initial value of the object, we can define a
      function that takes the value and returns an object:</p>

      <div class="highlight"><pre><code class="language-ocaml"># let stack init = object
    val mutable v = init
  
    method pop =
      match v with
      | hd :: tl -&gt;
        v &lt;- tl;
        Some hd
      | [] -&gt; None
  
    method push hd =
      v &lt;- hd :: v
  end ;;</code></pre><pre class="ge"><code class="language-ocaml">val stack : 'a list -&gt; &lt; pop : 'a option; push : 'a -&gt; unit &gt; = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># let s = stack [3; 2; 1] ;;</code></pre><pre class="ge"><code class="language-ocaml">val s : &lt; pop : int option; push : int -&gt; unit &gt; = &lt;obj&gt;</code></pre><pre><code class="language-ocaml"># s#pop ;;</code></pre><pre class="ge"><code class="language-ocaml">- : int option = Some 3</code></pre></div>

      <p>Note that the types of the function <code>stack</code> and
      the returned object now use the polymorphic type
      <code>'a</code>. When <code>stack</code> is invoked on a
      concrete value <code>[3; 2; 1]</code>, we get the same object
      type as before, with type <code>int</code> for the values on
      the stack.</p>
    </section>

    <section id="object-polymorphism" data-type="sect1">
      <h1>Object Polymorphism</h1>

      <p>Like polymorphic variants, methods can be used without an
      explicit type declaration:

	<a data-type="indexterm" data-primary="polymorphism" data-secondary="in objects">&nbsp;</a>
	<a data-type="indexterm" data-primary="objects" data-secondary="polymorphism of">&nbsp;</a></p>

      <div class="highlight"><pre><code class="language-ocaml"># let area sq = sq#width * sq#width ;;</code></pre><pre class="ge"><code class="language-ocaml">val area : &lt; width : int; .. &gt; -&gt; int = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># let minimize sq : unit = sq#resize 1 ;;</code></pre><pre class="ge"><code class="language-ocaml">val minimize : &lt; resize : int -&gt; unit; .. &gt; -&gt; unit = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># let limit sq = 
    if (area sq) &gt; 100 then minimize sq ;;</code></pre><pre class="ge"><code class="language-ocaml">val limit : &lt; resize : int -&gt; unit; width : int; .. &gt; -&gt; unit = &lt;fun&gt;</code></pre></div>

      <p>As you can see, object types are inferred automatically
      from the methods that are invoked on them.</p>

      <p>The type system will complain if it sees incompatible uses
      of the same method:</p>

      <div class="highlight"><pre><code class="language-ocaml"># let toggle sq b : unit = 
    if b then sq#resize `Fullscreen
    else minimize sq ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 76-78:
Error: This expression has type &lt; resize : [&gt; `Fullscreen ] -&gt; unit; .. &gt;
       but an expression was expected of type &lt; resize : int -&gt; unit; .. &gt;
       Types for method resize are incompatible
</code></pre></div>

      <p>The <code>..</code> in the inferred object types are
      ellipses, standing for other unspecified methods that the
      object may have. The type <code>&lt; width : float; ..
      &gt;</code> specifies an object that must have at least a
      <code>width</code> method, and possibly some others as well.
      Such object types are said to be <em>open</em>.

      <a data-type="indexterm" data-primary="open object types">&nbsp;</a></p>

      <p>We can manually <em>close</em> an object type using a type
      annotation:</p>

      <div class="highlight"><pre><code class="language-ocaml"># let area_closed (sq: &lt; width : int &gt;) = sq#width * sq#width ;;</code></pre><pre class="ge"><code class="language-ocaml">val area_closed : &lt; width : int &gt; -&gt; int = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># let sq = object
    method width = 30 
    method name = "sq" 
  end ;;</code></pre><pre class="ge"><code class="language-ocaml">val sq : &lt; name : string; width : int &gt; = &lt;obj&gt;</code></pre><pre><code class="language-ocaml"># area_closed sq ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 12-14:
Error: This expression has type &lt; name : string; width : int &gt;
       but an expression was expected of type &lt; width : int &gt;
       The second object type has no method name
</code></pre></div>

      <div data-type="note">
        <h1>Elisions Are Polymorphic</h1>

        <p>
	  The <code>..</code> in an open object type is an
          elision, standing for "possibly more methods." It may not
          be apparent from the syntax, but an elided object type is
          actually polymorphic. For example, if we try to write a
          type definition, we get an "unbound type variable"
          error:

	  <a data-type="indexterm" data-primary="polymorphism" data-secondary="row polymorphism">&nbsp;</a>
	  <a data-type="indexterm" data-primary="row polymorphism">&nbsp;</a>
	  <a data-type="indexterm" data-primary="ellipses (..)">&nbsp;</a>
	  <a data-type="indexterm" data-primary="type variables">&nbsp;</a></p>

	<div class="highlight"><pre><code class="language-ocaml"># type square = &lt; width : int; ..&gt; ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 0-32:
Error: A type variable is unbound in this type declaration.
In type &lt; width : int; .. &gt; as 'a the variable 'a is unbound
</code></pre></div>

	<p>
	  This is because <code>..</code> is really a special kind of
	  type variable called a <em>row variable</em>.</p>

	<p>
	  This kind of typing scheme using row variables is
	  called <em>row polymorphism</em>. Row polymorphism is also
	  used in polymorphic variant types, and there is a close
	  relationship between objects and polymorphic variants:
	  objects are to records what polymorphic variants are to
	  ordinary variants.</p>

      </div>

      <p>An object of type <code>&lt; pop : int option; ..
      &gt;</code> can be any object with a method <code>pop : int
      option</code>; it doesn't matter how it is implemented. When
      the method <code>#pop</code> is invoked, the actual method
      that is run is determined by the object:</p>


      <div class="highlight"><pre><code class="language-ocaml"># let print_pop st = Option.iter ~f:(printf "Popped: %d\n") st#pop ;;</code></pre><pre class="ge"><code class="language-ocaml">val print_pop : &lt; pop : int option; .. &gt; -&gt; unit = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># print_pop (stack [5;4;3;2;1]) ;;</code></pre><pre class="ge"><code class="language-ocaml">Popped: 5</code></pre><pre class="ge"><code class="language-ocaml">- : unit = ()</code></pre><pre><code class="language-ocaml"># let t = object
    method pop = Some (Time_ns.to_int_ns_since_epoch (Time_ns.now ()))
  end ;;</code></pre><pre class="ge"><code class="language-ocaml">val t : &lt; pop : int option &gt; = &lt;obj&gt;</code></pre><pre><code class="language-ocaml"># print_pop t ;;</code></pre><pre class="ge"><code class="language-ocaml"> ... </code></pre><pre class="ge"><code class="language-ocaml">- : unit = ()</code></pre></div>

    </section>

    <section id="immutable-objects" data-type="sect1">
      <h1>Immutable Objects</h1>

      <p>Many people consider object-oriented programming to be
      intrinsically imperative, where an object is like a state
      machine. Sending a message to an object causes it to change
      state, possibly sending messages to other
      objects.

	<a data-type="indexterm" data-primary="objects" data-secondary="immutabile">&nbsp;</a></p>

      <p>Indeed, in many programs this makes sense, but it is by no
      means required. Let's define a function that creates
      immutable stack objects:</p>

      <div class="highlight"><pre><code class="language-ocaml"># let imm_stack init = object
    val v = init
  
    method pop =
      match v with
      | hd :: tl -&gt; Some (hd, {&lt; v = tl &gt;})
      | [] -&gt; None 
  
    method push hd = 
      {&lt; v = hd :: v &gt;}
  end ;;</code></pre><pre class="ge"><code class="language-ocaml">
val imm_stack :
  'a list -&gt; (&lt; pop : ('a * 'b) option; push : 'a -&gt; 'b &gt; as 'b) = &lt;fun&gt;
</code></pre></div>

      <p>The key parts of this implementation are in the
      <code>pop</code> and <code>push</code> methods. The
      expression <code>{&lt; ... &gt;}</code> produces a copy of
      the current object, with the same type, and the specified
      fields updated. In other words, the <code>push hd</code>
      method produces a copy of the object, with <code>v</code>
      replaced by <code>hd :: v</code>. The original object is not
      modified:</p>

      <div class="highlight"><pre><code class="language-ocaml"># let s = imm_stack [3; 2; 1] ;;</code></pre><pre class="ge"><code class="language-ocaml">val s : &lt; pop : (int * 'a) option; push : int -&gt; 'a &gt; as 'a = &lt;obj&gt;</code></pre><pre><code class="language-ocaml"># let t = s#push 4 ;;</code></pre><pre class="ge"><code class="language-ocaml">val t : &lt; pop : (int * 'a) option; push : int -&gt; 'a &gt; as 'a = &lt;obj&gt;</code></pre><pre><code class="language-ocaml"># s#pop ;;</code></pre><pre class="ge"><code class="language-ocaml">
- : (int * (&lt; pop : 'a; push : int -&gt; 'b &gt; as 'b)) option as 'a =
Some (3, &lt;obj&gt;)
</code></pre><pre><code class="language-ocaml"># t#pop ;;</code></pre><pre class="ge"><code class="language-ocaml">
- : (int * (&lt; pop : 'a; push : int -&gt; 'b &gt; as 'b)) option as 'a =
Some (4, &lt;obj&gt;)
</code></pre></div>

      <p>There are some restrictions on the use of the expression
      <code>{&lt; ... &gt;}</code>. It can be used only within a
      method body, and only the values of fields may be updated.
      Method implementations are fixed at the time the object is
      created; they cannot be changed <span class="keep-together">dynamically</span>.</p>
    </section>

    <section id="when-to-use-objects" data-type="sect1">
      <h1>When to Use Objects</h1>

      <p>You might wonder when to use objects in OCaml, which has a
      multitude of alternative mechanisms to express the similar
      concepts. First-class modules are more expressive (a module
      can include types, while classes and objects cannot).
      Modules, functors, and data types also offer a wide range of
      ways to express program structure. In fact, many seasoned
      OCaml programmers rarely use classes and objects, if at
      all.

	<a data-type="indexterm" data-primary="first-class modules" data-secondary="vs. objects">&nbsp;</a>
	<a data-type="indexterm" data-primary="objects" data-secondary="benefits and drawbacks of">&nbsp;</a></p>

      <p>Objects have some advantages over records: they don't
      require type definitions, and their support for row
      polymorphism makes them more flexible. However, the heavy
      syntax and additional runtime cost means that objects are
      rarely used in place of records.</p>

      <p>The real benefits of objects come from the class system.
      Classes support inheritance and open recursion. Open
      recursion allows interdependent parts of an object to be
      defined separately. This works because calls between the
      methods of an object are determined when the object is
      instantiated, a form of <em>late</em> binding. This makes it
      possible (and necessary) for one method to refer to other
      methods in the object without knowing statically how they
      will be implemented.

	<a data-type="indexterm" data-primary="late binding">&nbsp;</a>
	<a data-type="indexterm" data-primary="recursion" data-secondary="open recursion">&nbsp;</a>
	<a data-type="indexterm" data-primary="open recursion">&nbsp;</a>
	<a data-type="indexterm" data-primary="classes" data-secondary="benefits of">&nbsp;</a></p>

      <p>In contrast, modules use early binding. If you want to
      parameterize your module code so that some part of it can be
      implemented later, you would write a function or functor.
      This is more explicit, but often more verbose than overriding
      a method in a class.</p>

      <p>In general, a rule of thumb is: use classes and objects in
      situations where open recursion is a big win. Two good
      examples are Xavier Leroy's <a href="http://gallium.inria.fr/~xleroy/software.html#cryptokit">Cryptokit</a>,
      which provides a variety of cryptographic primitives that can
      be combined in building-block style; and the <a href="http://cristal.inria.fr/camlimages/">Camlimages</a> library,
      which manipulates various graphical file formats. Camlimages
      also provides a module-based version of the same library,
      letting you choose between functional and object-oriented
      styles depending on your problem domain.

	<a data-type="indexterm" data-primary="Camlimages library">&nbsp;</a>
	<a data-type="indexterm" data-primary="Cryptokit library">&nbsp;</a>
	<a data-type="indexterm" data-primary="libraries" data-secondary="Cryptokit">&nbsp;</a>
	<a data-type="indexterm" data-primary="libraries" data-secondary="Camlimages">&nbsp;</a>
	<a data-type="indexterm" data-primary="external libraries" data-secondary="Camlimages">&nbsp;</a>
	<a data-type="indexterm" data-primary="external libraries" data-secondary="Cryptokit">&nbsp;</a></p>

      <p>We'll introduce you to classes, and examples using open
      recursion, in <a href="12-classes.html#classes" data-type="xref">Chapter 12, Classes</a>.</p>
    </section>

    <section id="subtyping" data-type="sect1">
      <h1>Subtyping</h1>

      <p>Subtyping is a central concept in object-oriented
      programming. It governs when an object with one type
      <em>A</em> can be used in an expression that expects an
      object of another type <em>B</em>. When this is true, we say
      that <em>A</em> is a <em>subtype</em> of <em>B</em>. More
      concretely, subtyping restricts when the coercion operator
      <code>e :&gt; t</code> can be applied. This coercion works
      only if the type of <code>e</code> is a subtype of
      <code>t</code>.

      <a data-type="indexterm" data-primary="subtyping" data-secondary="basics of">&nbsp;</a>
      <a data-type="indexterm" data-primary="objects" data-secondary="subtyping and" id="OBsub">&nbsp;</a>
      </p>

      <section id="width-subtyping" data-type="sect2">
        <h2>Width Subtyping</h2>

        <p>To explore this, let's define some simple object types
        for geometric shapes. The generic type <code>shape</code>
        has a method to compute the area, and <code>square</code>
        and <code>circle</code> are specific kinds of
        shapes:

	  <a data-type="indexterm" data-primary="geometric shapes">&nbsp;</a>
	  <a data-type="indexterm" data-primary="width subtyping">&nbsp;</a>
	  <a data-type="indexterm" data-primary="subtyping" data-secondary="width subtyping">&nbsp;</a></p>

        <div class="highlight"><pre><code class="language-ocaml">type shape = &lt; area : float &gt;

type square = &lt; area : float; width : int &gt;

let square w = object
  method area = Float.of_int (w * w)
  method width = w
end

type circle = &lt; area : float; radius : int &gt;

let circle r = object
  method area = 3.14 *. (Float.of_int r) ** 2.0
  method radius = r
end

</code></pre></div>

        <p>A <code>square</code> has a method <code>area</code>
        just like a <code>shape</code>, and an additional method
        <code>width</code>. Still, we expect a <code>square</code>
        to be a <code>shape</code>, and it is. The coercion
        <code>:&gt;</code> must be explicit:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let shape w : shape = square w ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 22-30:
Error: This expression has type &lt; area : float; width : int &gt;
       but an expression was expected of type shape
       The second object type has no method width
</code></pre><pre><code class="language-ocaml"># let shape w : shape = (square w :&gt; shape) ;;</code></pre><pre class="ge"><code class="language-ocaml">val shape : int -&gt; shape = &lt;fun&gt;</code></pre></div>

        <p>This form of object subtyping is called <em>width</em>
        subtyping. Width subtyping means that an object type
        <em>A</em> is a subtype of <em>B</em>, if <em>A</em> has
        all of the methods of <em>B</em>, and possibly more. A
        <code>square</code> is a subtype of <code>shape</code>
        because it implements all of the methods of
        <code>shape</code> (the <code>area</code> method).</p>
      </section>

      <section id="depth-subtyping" data-type="sect2">
        <h2>Depth Subtyping</h2>

        <p>We can also use <em>depth</em> subtyping with objects.
        Depth subtyping allows us coerce an object if its
        individual methods could safely be coerced. So an object
        type <code>&lt; m: t1 &gt;</code> is a subtype of
        <code>&lt; m: t2 &gt;</code> if <code>t1</code> is a
        subtype of <code>t2</code>.

	<a data-type="indexterm" data-primary="depth subtyping">&nbsp;</a>
	<a data-type="indexterm" data-primary="subtyping" data-secondary="depth subtyping">&nbsp;</a></p>

        <p>For example, we can create two objects with a
        <code>shape</code> method:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let coin = object
    method shape = circle 5
    method color = "silver"
  end ;;</code></pre><pre class="ge"><code class="language-ocaml">val coin : &lt; color : string; shape : &lt; area : float; radius : int &gt; &gt; = &lt;obj&gt;</code></pre><pre><code class="language-ocaml"># let map = object
    method shape = square 10
  end ;;</code></pre><pre class="ge"><code class="language-ocaml">val map : &lt; shape : &lt; area : float; width : int &gt; &gt; = &lt;obj&gt;</code></pre></div>

        <p>Both these objects have a <code>shape</code> method
        whose type is a subtype of the <code>shape</code> type, so
        they can both be coerced into the object type <code>&lt;
        shape : shape &gt;</code>:</p>

        <div class="highlight"><pre><code class="language-ocaml"># type item = &lt; shape : shape &gt; ;;</code></pre><pre class="ge"><code class="language-ocaml">type item = &lt; shape : shape &gt;</code></pre><pre><code class="language-ocaml"># let items = [ (coin :&gt; item) ; (map :&gt; item) ] ;;</code></pre><pre class="ge"><code class="language-ocaml">val items : item list = [&lt;obj&gt;; &lt;obj&gt;]</code></pre></div>

        <div data-type="note">
          <h1>Polymorphic Variant Subtyping</h1>

          <p>Subtyping can also be used to coerce a polymorphic
            variant into a larger polymorphic variant type. A
            polymorphic variant type <em>A</em> is a subtype of
            <em>B</em>, if the tags of <em>A</em> are a subset of the
            tags of <em>B</em>:</p>

          <div class="highlight"><pre><code class="language-ocaml"># type num = [ `Int of int | `Float of float ] ;;</code></pre><pre class="ge"><code class="language-ocaml">type num = [ `Float of float | `Int of int ]</code></pre><pre><code class="language-ocaml"># type const = [ num | `String of string ] ;;</code></pre><pre class="ge"><code class="language-ocaml">type const = [ `Float of float | `Int of int | `String of string ]</code></pre><pre><code class="language-ocaml"># let n : num = `Int 3 ;;</code></pre><pre class="ge"><code class="language-ocaml">val n : num = `Int 3</code></pre><pre><code class="language-ocaml"># let c : const = (n :&gt; const) ;;</code></pre><pre class="ge"><code class="language-ocaml">val c : const = `Int 3</code></pre></div>
        </div>
      </section>

      <section id="variance" data-type="sect2">
        <h2>Variance</h2>

        <p>What about types built from object types? If a
        <code>square</code> is a <code>shape</code>, we expect a
        <code>square list</code> to be a <code>shape list</code>.
        OCaml does indeed allow such coercions:<a data-type="indexterm" data-primary="variance" id="var">&nbsp;</a><a data-type="indexterm" data-primary="subtyping" data-secondary="variance and" id="SUBvar">&nbsp;</a></p>

        <div class="highlight"><pre><code class="language-ocaml"># let squares: square list = [ square 10; square 20 ] ;;</code></pre><pre class="ge"><code class="language-ocaml">val squares : square list = [&lt;obj&gt;; &lt;obj&gt;]</code></pre><pre><code class="language-ocaml"># let shapes: shape list = (squares :&gt; shape list) ;;</code></pre><pre class="ge"><code class="language-ocaml">val shapes : shape list = [&lt;obj&gt;; &lt;obj&gt;]</code></pre></div>

        <p>Note that this relies on lists being immutable. It would
        not be safe to treat a <code>square array</code> as a
        <code>shape array</code> because it would allow you to
        store nonsquare shapes into what should be an array of
        squares. OCaml recognizes this and does not allow the
        coercion:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let square_array: square array = [| square 10; square 20 |] ;;</code></pre><pre class="ge"><code class="language-ocaml">val square_array : square array = [|&lt;obj&gt;; &lt;obj&gt;|]</code></pre><pre><code class="language-ocaml"># let shape_array: shape array = (square_array :&gt; shape array) ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 31-60:
Error: Type square array is not a subtype of shape array 
       Type square = &lt; area : float; width : int &gt;
       is not compatible with type shape = &lt; area : float &gt; 
       The second object type has no method width
</code></pre></div>

        <p>We say that <code>'a list</code> is <em>covariant</em>
        (in <code>'a</code>), while <code>'a array</code> is
        <em>invariant</em>.
	
	<a data-type="indexterm" data-primary="invariance">&nbsp;</a>
	<a data-type="indexterm" data-primary="covariance">&nbsp;</a></p>

        <p>Subtyping function types requires a third class of
        variance. A function with type <code>square -&gt;
        string</code> cannot be used with type <code>shape -&gt;
        string</code> because it expects its argument to be a
        <code>square</code> and would not know what to do with a
        <code>circle</code>. However, a function with type
        <code>shape -&gt; string</code> <em>can</em> safely be used
        with type <code>square -&gt; string</code>:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let shape_to_string: shape -&gt; string = 
    fun s -&gt; sprintf "Shape(%F)" s#area ;;</code></pre><pre class="ge"><code class="language-ocaml">val shape_to_string : shape -&gt; string = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># let square_to_string: square -&gt; string = 
    (shape_to_string :&gt; square -&gt; string) ;;</code></pre><pre class="ge"><code class="language-ocaml">val square_to_string : square -&gt; string = &lt;fun&gt;</code></pre></div>

        <p>We say that <code>'a -&gt; string</code> is
        <em>contravariant</em> in <code>'a</code>. In general,
        function types are contravariant in their arguments and
        covariant in their results.

	<a data-type="indexterm" data-primary="contravariance">&nbsp;</a></p>

        <aside data-type="sidebar">
          <h5>Variance Annotations</h5>

          <p>OCaml works out the variance of a type using that
          type's definition:</p>

          <div class="highlight"><pre><code class="language-ocaml"># module Either = struct
    type ('a, 'b) t = 
      | Left of 'a
      | Right of 'b
    let left x = Left x
    let right x = Right x
  end ;;</code></pre><pre class="ge"><code class="language-ocaml">
module Either :
  sig
    type ('a, 'b) t = Left of 'a | Right of 'b
    val left : 'a -&gt; ('a, 'b) t
    val right : 'a -&gt; ('b, 'a) t
  end
</code></pre><pre><code class="language-ocaml"># (Either.left (square 40) :&gt; (shape, shape) Either.t) ;;</code></pre><pre class="ge"><code class="language-ocaml">- : (shape, shape) Either.t = Either.Left &lt;obj&gt;</code></pre></div>

          <p>However, if the definition is hidden by a signature,
          then OCaml is forced to assume that the type is
          invariant:</p>

          <div class="highlight"><pre><code class="language-ocaml"># module AbstractEither : sig 
    type ('a, 'b) t
    val left: 'a -&gt; ('a, 'b) t
    val right: 'b -&gt; ('a, 'b) t
  end = Either ;;</code></pre><pre class="ge"><code class="language-ocaml">
module AbstractEither :
  sig
    type ('a, 'b) t
    val left : 'a -&gt; ('a, 'b) t
    val right : 'b -&gt; ('a, 'b) t
  end
</code></pre><pre><code class="language-ocaml"># (AbstractEither.left (square 40) :&gt; (shape, shape) AbstractEither.t) ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 1-32:
Error: This expression cannot be coerced to type
         (shape, shape) AbstractEither.t;
       it has type (&lt; area : float; width : int &gt;, 'a) AbstractEither.t
       but is here used with type (shape, shape) AbstractEither.t
       Type &lt; area : float; width : int &gt; is not compatible with type
         shape = &lt; area : float &gt; 
       The second object type has no method width
</code></pre></div>

          <p>We can fix this by adding <em>variance
          annotations</em> to the type's parameters in the
          signature: <code>+</code> for covariance or
          <code>-</code> for contravariance:</p>

          <div class="highlight"><pre><code class="language-ocaml"># module VarEither : sig 
    type (+'a, +'b) t
    val left: 'a -&gt; ('a, 'b) t
    val right: 'b -&gt; ('a, 'b) t
  end = Either ;;</code></pre><pre class="ge"><code class="language-ocaml">
module VarEither :
  sig
    type (+'a, +'b) t
    val left : 'a -&gt; ('a, 'b) t
    val right : 'b -&gt; ('a, 'b) t
  end
</code></pre><pre><code class="language-ocaml"># (VarEither.left (square 40) :&gt; (shape, shape) VarEither.t) ;;</code></pre><pre class="ge"><code class="language-ocaml">- : (shape, shape) VarEither.t = &lt;abstr&gt;</code></pre></div>
        </aside>

        <p>For a more concrete example of variance, let's create
        some stacks containing shapes by applying our
        <code>stack</code> function to some squares and some
        circles:</p>

        <div class="highlight"><pre><code class="language-ocaml">type 'a stack = &lt; pop: 'a option; push: 'a -&gt; unit &gt;

let square_stack: square stack = stack [square 30; square 10]

let circle_stack: circle stack = stack [circle 20; circle 40]</code></pre></div>

        <p>If we wanted to write a function that took a list of
        such stacks and found the total area of their shapes, we
        might try:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let total_area (shape_stacks: shape stack list) =
    let stack_area acc st = 
      let rec loop acc =
        match st#pop with
        | Some s -&gt; loop (acc +. s#area)
        | None -&gt; acc
      in
      loop acc
    in
    List.fold ~init:0.0 ~f:stack_area shape_stacks ;;</code></pre><pre class="ge"><code class="language-ocaml">val total_area : shape stack list -&gt; float = &lt;fun&gt;</code></pre></div>

        <p>However, when we try to apply this function to our
        objects, we get an error:</p>

        <div class="highlight"><pre><code class="language-ocaml"># total_area [(square_stack :&gt; shape stack); (circle_stack :&gt; shape stack)] ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 12-41:
Error: Type square stack = &lt; pop : square option; push : square -&gt; unit &gt;
       is not a subtype of
         shape stack = &lt; pop : shape option; push : shape -&gt; unit &gt; 
       Type shape = &lt; area : float &gt; is not a subtype of
         square = &lt; area : float; width : int &gt; 
</code></pre></div>

        <p>As you can see, <code>square stack</code> and
        <code>circle stack</code> are not subtypes of <code>shape
        stack</code>. The problem is with the <code>push</code>
        method. For <code>shape stack</code>, the <code>push</code>
        method takes an arbitrary <code>shape</code>. So if we
        could coerce a <code>square stack</code> to a <code>shape
        stack</code>, then it would be possible to push an
        arbitrary shape onto <code>square stack</code>, which would
        be an error.</p>

        <p>Another way of looking at this is that <code>&lt; push:
        'a -&gt; unit; .. &gt;</code> is contravariant in
        <code>'a</code>, so <code>&lt; push: square -&gt; unit;
        pop: square option &gt;</code> cannot be a subtype of
        <span><code>&lt; push: shape -&gt; unit; pop: shape option
        &gt;</code></span>.</p>

        <p>Still, the <code>total_area</code> function should be
        fine, in principle. It doesn't call <code>push</code>, so
        it isn't making that error. To make it work, we need to use
        a more precise type that indicates we are not going to be
        using the <code>set</code> method. We define a type
        <code>readonly_stack</code> and confirm that we can coerce
        the list of <code>stack</code>s to it:</p>

        <div class="highlight"><pre><code class="language-ocaml"># type 'a readonly_stack = &lt; pop : 'a option &gt; ;;</code></pre><pre class="ge"><code class="language-ocaml">type 'a readonly_stack = &lt; pop : 'a option &gt;</code></pre><pre><code class="language-ocaml"># let total_area (shape_stacks: shape readonly_stack list) =
    let stack_area acc st = 
      let rec loop acc =
        match st#pop with
        | Some s -&gt; loop (acc +. s#area)
        | None -&gt; acc
      in
      loop acc
    in
    List.fold ~init:0.0 ~f:stack_area shape_stacks ;;</code></pre><pre class="ge"><code class="language-ocaml">val total_area : shape readonly_stack list -&gt; float = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># total_area [(square_stack :&gt; shape readonly_stack); (circle_stack :&gt; 
                                                         shape readonly_stack)] ;;</code></pre><pre class="ge"><code class="language-ocaml">- : float = 7280.</code></pre></div>

        <p>Aspects of this section may seem fairly complicated, but
        it should be pointed out that this typing <em>works</em>,
        and in the end, the type annotations are fairly minor. In
        most typed object-oriented languages, these coercions would
        simply not be possible. For example, in C++, a STL type
        <code>list&lt;T&gt;</code> is invariant in <code>T</code>,
        so it is simply not possible to use
        <code>list&lt;square&gt;</code> where
        <code>list&lt;shape&gt;</code> is expected (at least
        safely). The situation is similar in Java, although Java
        has an escape hatch that allows the program to fall back to
        dynamic typing. The situation in OCaml is much better: it
        works, it is statically checked, and the annotations are
        pretty simple.<a data-type="indexterm" data-startref="var">&nbsp;</a><a data-type="indexterm" data-startref="SUBvar">&nbsp;</a></p>
      </section>

      <section id="narrowing" data-type="sect2">
        <h2>Narrowing</h2>

        <p>Narrowing, also called <em>down casting</em>, is the
        ability to coerce an object to one of its subtypes. For
        example, if we have a list of shapes <code>shape
        list</code>, we might know (for some reason) what the
        actual type of each shape is. Perhaps we know that all
        objects in the list have type <code>square</code>. In this
        case, <em>narrowing</em> would allow the recasting of the
        object from type <code>shape</code> to type
        <code>square</code>. Many languages support narrowing
        through dynamic type checking. For example, in Java, a
        coercion <code>(Square) x</code> is allowed if the value
        <code>x</code> has type <code>Square</code> or one of its
        subtypes; otherwise the coercion throws an
        exception.

	<a data-type="indexterm" data-primary="dynamic type checking">&nbsp;</a>
	<a data-type="indexterm" data-primary="down casting">&nbsp;</a>
	<a data-type="indexterm" data-primary="narrowing">&nbsp;</a>
	<a data-type="indexterm" data-primary="objects" data-secondary="narrowing and">&nbsp;</a></p>

        <p>Narrowing is <em>not permitted</em> in OCaml.
        Period.</p>

        <p>Why? There are two reasonable explanations, one based on
        a design principle, and another technical (the technical
        reason is simple: it is hard to implement).</p>

        <p>The design argument is this: narrowing violates
        abstraction. In fact, with a structural typing system like
        in OCaml, narrowing would essentially provide the ability
        to enumerate the methods in an object. To check whether an
        object <code>obj</code> has some method <code>foo :
        int</code>, one would attempt a coercion <code>(obj :&gt;
        &lt; foo : int &gt;)</code>.</p>

        <p>More pragmatically, narrowing leads to poor
        object-oriented style. Consider the following Java code,
        which returns the name of a shape object:</p>

        <div class="highlight"><pre><code class="language-ocaml">String GetShapeName(Shape s) {
  if (s instanceof Square) {
    return "Square";
  } else if (s instanceof Circle) {
    return "Circle";
  } else {
    return "Other";
  }
}
</code></pre></div>

        <p>Most programmers would consider this code to be "wrong."
        Instead of performing a case analysis on the type of
        object, it would be better to define a method to return the
        name of the shape. Instead of calling
        <code>GetShapeName(s)</code>, we should call
        <code>s.Name()</code> instead.</p>

        <p>However, the situation is not always so obvious. The
        following code checks whether an array of shapes looks like
        a "barbell," composed of two <code>Circle</code> objects
        separated by a <code>Line</code>, where the circles have
        the same radius:</p>

        <div class="highlight"><pre><code class="language-ocaml">boolean IsBarbell(Shape[] s) {
  return s.length == 3 &amp;&amp; (s[0] instanceof Circle) &amp;&amp;
    (s[1] instanceof Line) &amp;&amp; (s[2] instanceof Circle) &amp;&amp;
        ((Circle) s[0]).radius() == ((Circle) s[2]).radius();
}
</code></pre></div>

        <p>In this case, it is much less clear how to augment the
        <code>Shape</code> class to support this kind of pattern
        analysis. It is also not obvious that object-oriented
        programming is well-suited for this situation. Pattern
        matching seems like a better fit:</p>
        <div class="highlight"><pre><code class="language-ocaml">let is_barbell = function
| [Circle r1; Line _; Circle r2] when r1 = r2 -&gt; true
| _ -&gt; false</code></pre></div>

        <p>Regardless, there is a solution if you find yourself in
        this situation, which is to augment the classes with
        variants. You can define a method <code>variant</code> that
        injects the actual object into a variant type:</p>
        <div class="highlight"><pre><code class="language-ocaml">type shape = &lt; variant : repr; area : float&gt;
and circle = &lt; variant : repr; area : float; radius : int &gt;
and line = &lt; variant : repr; area : float; length : int &gt;
and repr =
 | Circle of circle
 | Line of line;;

let is_barbell = function
| [s1; s2; s3] -&gt;
   (match s1#variant, s2#variant, s3#variant with
    | Circle c1, Line _, Circle c2 when c1#radius = c2#radius -&gt; true
    | _ -&gt; false)
| _ -&gt; false;;</code></pre></div>

        <p>This pattern works, but it has drawbacks. In particular,
        the recursive type definition should make it clear that
        this pattern is essentially equivalent to using variants,
        and that objects do not provide much value here.</p>
      </section>

      <section id="subtyping-vs.-row-polymorphism" data-type="sect2">
        <h2>Subtyping Versus Row Polymorphism</h2>

        <p>There is considerable overlap between subtyping and row
        polymorphism. Both mechanisms allow you to write functions
        that can be applied to objects of different types. In these
        cases, row polymorphism is usually preferred over subtyping
        because it does not require explicit coercions, and it
        preserves more type information, allowing functions like
        the following:

	  <a data-type="indexterm" data-primary="polymorphism" data-secondary="row polymorphism">&nbsp;</a>
	  <a data-type="indexterm" data-primary="row polymorphism">&nbsp;</a>
	  <a data-type="indexterm" data-primary="subtyping" data-secondary="vs. row polymorphism">&nbsp;</a></p>

        <div class="highlight"><pre><code class="language-ocaml"># let remove_large l =
    List.filter ~f:(fun s -&gt; s#area &lt;= 100.) l ;;</code></pre><pre class="ge"><code class="language-ocaml">val remove_large : (&lt; area : float; .. &gt; as 'a) list -&gt; 'a list = &lt;fun&gt;</code></pre></div>

        <p>The return type of this function is built from the open
        object type of its argument, preserving any additional
        methods that it may have:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let squares : &lt; area : float; width : int &gt; list = 
    [square 5; square 15; square 10] ;;</code></pre><pre class="ge"><code class="language-ocaml">val squares : &lt; area : float; width : int &gt; list = [&lt;obj&gt;; &lt;obj&gt;; &lt;obj&gt;]</code></pre><pre><code class="language-ocaml"># remove_large squares ;;</code></pre><pre class="ge"><code class="language-ocaml">- : &lt; area : float; width : int &gt; list = [&lt;obj&gt;; &lt;obj&gt;]</code></pre></div>

        <p>Writing a similar function with a closed type and
        applying it using subtyping does not preserve the methods
        of the argument: the returned object is only known to have
        an <code>area</code> method:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let remove_large (l: &lt; area : float &gt; list) = 
    List.filter ~f:(fun s -&gt; s#area &lt;= 100.) l ;;</code></pre><pre class="ge"><code class="language-ocaml">val remove_large : &lt; area : float &gt; list -&gt; &lt; area : float &gt; list = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># remove_large (squares :&gt; &lt; area : float &gt; list ) ;;</code></pre><pre class="ge"><code class="language-ocaml">- : &lt; area : float &gt; list = [&lt;obj&gt;; &lt;obj&gt;]</code></pre></div>

        <p>However, there are some situations where we cannot use
        row polymorphism. In particular, row polymorphism cannot be
        used to place different types of object in the same
        container. For example, lists of heterogeneous elements
        cannot be created using row polymorphism:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let hlist: &lt; area: float; ..&gt; list = [square 10; circle 30] ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 49-58:
Error: This expression has type &lt; area : float; radius : int &gt;
       but an expression was expected of type &lt; area : float; width : int &gt;
       The second object type has no method radius
</code></pre></div>

        <p>Similarly, we cannot use row polymorphism to store
        different types of object in the same reference:</p>

        <div class="highlight"><pre><code class="language-ocaml"># let shape_ref: &lt; area: float; ..&gt; ref = ref (square 40) ;;</code></pre><pre class="ge"><code class="language-ocaml">val shape_ref : &lt; area : float; width : int &gt; ref = {contents = &lt;obj&gt;}</code></pre><pre><code class="language-ocaml"># shape_ref := circle 20 ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 13-22:
Error: This expression has type &lt; area : float; radius : int &gt;
       but an expression was expected of type &lt; area : float; width : int &gt;
       The second object type has no method radius
</code></pre></div>

        <p>In both these cases we must use subtyping:<a data-type="indexterm" data-startref="OBsub">&nbsp;</a></p>

        <div class="highlight"><pre><code class="language-ocaml"># let hlist: shape list = [(square 10 :&gt; shape); (circle 30 :&gt; shape)] ;;</code></pre><pre class="ge"><code class="language-ocaml">val hlist : shape list = [&lt;obj&gt;; &lt;obj&gt;]</code></pre><pre><code class="language-ocaml"># let shape_ref: shape ref = ref (square 40 :&gt; shape) ;;</code></pre><pre class="ge"><code class="language-ocaml">val shape_ref : shape ref = {contents = &lt;obj&gt;}</code></pre><pre><code class="language-ocaml"># shape_ref := (circle 20 :&gt; shape) ;;</code></pre><pre class="ge"><code class="language-ocaml">- : unit = ()</code></pre></div>

        <div data-type="note">
          <h1>Production Note</h1>

          <p>This chapter contains significant contributions from
          Leo White.</p>
        </div>
      </section>
    </section>
  </section>
</article></div><a class="next-chapter" href="12-classes.html"><div class="content"><h1><small>Next: Chapter 12</small>Classes</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script><script src="js/discourse.js"></script></body></html>