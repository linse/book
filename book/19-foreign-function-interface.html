<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Mac OS X version 4.9.20"/>

  <title></title>
</head>

<body>
  <section xmlns="http://www.w3.org/1999/xhtml" id="foreign-function-interface" data-type="chapter">
    <h1>Foreign Function Interface</h1>

    <p>OCaml has several options available to interact with
    non-OCaml code. The compiler can link with external system
    libraries via C code and also can produce standalone native
    object files that can be embedded within other non-OCaml
    applications.<idx>programming/language interfaces</idx>
    <idx>foreign function interface (FFI)/basics of</idx><idx id="INTERffi">interfaces/foreign function interface (FFI)</idx></p>

    <p>The mechanism by which code in one programming language can
    invoke routines in a different programming language is called a
    <em>foreign function interface</em>. This chapter will:</p>

    <ul>
      <li>
        <p>Show how to call routines in C libraries directly from
        your OCaml code</p>
      </li>

      <li>
        <p>Teach you how to build higher-level abstractions in
        OCaml from the low-level C bindings</p>
      </li>

      <li>
        <p>Work through some full examples for binding a terminal
        interface and UNIX date/time functions</p>
      </li>
    </ul>

    <p>The simplest foreign function interface in OCaml doesn't
    even require you to write any C code at all! The Ctypes library
    lets you define the C interface in pure OCaml, and the library
    then takes care of loading the C symbols and invoking the
    foreign function call.<idx>libffi library</idx><idx>Ncurses terminal toolkit</idx><idx>Ctypes library/installation of</idx></p>

    <p>Let's dive straight into a realistic example to show you how
    the library looks. We'll create a binding to the Ncurses
    terminal toolkit, as it's widely available on most systems and
    doesn't have any complex dependencies.</p>

    <div data-type="note">
      <h1>Installing the Ctypes Library</h1>

      <p>If you want to use Ctypes interactively, you'll also need to
      install the <a href="https://github.com/atgreen/libffi"><code>libffi</code></a>
      library as a prerequisite to using Ctypes. It's a fairly
      popular library and should be available in your OS package
      manager. Try `opam depext -ui ctypes-foreign`.</p>

      <p>Once that's done, Ctypes is available via OPAM as
      usual:</p>
    </div>
    <link rel="import" href="code/ffi/install.rawsh"/>

    <p>You'll also need the Ncurses library for the first example.
    This comes preinstalled on many operating systems such as Mac
    OS X, and Debian Linux provides it as the
    <code>libncurses5-dev</code> package.</p>

    <section id="example-a-terminal-interface" data-type="sect1">
      <h1>Example: A Terminal Interface</h1>

      <p>Ncurses is a library to help build terminal-independent
      text interfaces in a reasonably efficient way. It's used in
      console mail clients like Mutt and Pine, and console web
      browsers such as Lynx.<idx id="FFItermint">foreign function interface (FFI)/terminal interface example</idx></p>

      <p>The full C interface is quite large and is explained in
      the online <a href="http://www.gnu.org/software/ncurses/">documentation</a>.
      We'll just use the small excerpt, since we just want to
      demonstrate Ctypes in action:<idx>Ctypes library/terminal interface example</idx></p>
      <link rel="import" href="code/ffi/ncurses/ncurses.h"/>

      <p>The Ncurses functions either operate on the current
      pseudoterminal or on a window that has been created via
      <code>newwin</code>. The <code>WINDOW</code> structure holds
      the internal library state and is considered abstract outside
      of Ncurses. Ncurses clients just need to store the pointer
      somewhere and pass it back to Ncurses library calls, which in
      turn dereference its contents.</p>

      <p>Note that there are over 200 library calls in Ncurses, so
      we're only binding a select few for this example. The
      <code>initscr</code> and <code>newwin</code> create
      <code>WINDOW</code> pointers for the global and subwindows,
      respectively. The <code>mvwaddrstr</code> takes a window, x/y
      offsets, and a string and writes to the screen at that
      location. The terminal is only updated after
      <code>refresh</code> or <code>wrefresh</code> are called.</p>

      <p>Ctypes provides an OCaml interface that lets you map these
      C functions to equivalent OCaml functions. The library takes
      care of converting OCaml function calls and arguments into
      the C calling convention, invoking the foreign call within
      the C library and finally returning the result as an OCaml
      value.</p>

      <p>Let's begin by defining the basic values we need, starting
      with the <code>WINDOW</code> state pointer:</p>
      <link rel="import" href="code/ffi/ncurses/ncurses.ml"/>

      <p>We don't know the internal representation of the window
      pointer, so we treat it as a C void pointer. We'll improve on
      this later on in the chapter, but it's good enough for now.
      The second statement defines an OCaml value that represents
      the <code>WINDOW</code> C pointer. This value is used later
      in the Ctypes function definitions:</p>
      <link rel="import" href="code/ffi/ncurses/ncurses.ml" part="1"/>

      <p>That's all we need to invoke our first function call to
      <code>initscr</code> to initialize the terminal. The
      <code>foreign</code> function accepts two parameters:</p>

      <ul>
        <li>
          <p>The C function call name, which is looked up using the
          <code>dlsym</code> POSIX function.</p>
        </li>

        <li>
          <p>A value that defines the complete set of C function
          arguments and its return type. The <code>@-&gt;</code>
          operator adds an argument to the C parameter list, and
          <code>returning</code> terminates the parameter list with
          the return type.</p>
        </li>
      </ul>

      <p>The remainder of the Ncurses binding simply expands on
      these definitions:</p>
      <link rel="import" href="code/ffi/ncurses/ncurses.ml" part="2"/>

      <p>These definitions are all straightforward mappings from
      the C declarations in the Ncurses header file. Note that the
      <code>string</code> and <code>int</code> values here are
      nothing to do with OCaml type declarations; instead, they are
      values that come from opening the <code>Ctypes</code> module
      at the top of the file.</p>

      <p>Most of the parameters in the Ncurses example represent
      fairly simple scalar C types, except for <code>window</code>
      (a pointer to the library state) and <code>string</code>,
      which maps from OCaml strings that have a specific length
      onto C character buffers whose length is defined by a
      terminating null character that immediately follows the
      string data.</p>

      <p>The module signature for <code>ncurses.mli</code> looks
      much like a normal OCaml signature. You can infer it directly
      from the <code>ncurses.ml</code> by running a special build
      target:</p>
      <link rel="import" href="code/ffi/ncurses/infer_ncurses.sh"/>

      <p>The <code>inferred.mli</code> target instructs the
      compiler to generate the default signature for a module file
      and places it in the <code>_build</code> directory as a
      normal output. You should normally copy it out into your
      source directory and customize it to improve its safety for
      external callers by making some of its internals more
      abstract.</p>

      <p>Here's the customized interface that we can safely use
      from other libraries:</p>
      <link rel="import" href="code/ffi/ncurses/ncurses.mli"/>

      <p>The <code>window</code> type is left abstract in the
      signature to ensure that window pointers can only be
      constructed via the <code>Ncurses.initscr</code> function.
      This prevents void pointers obtained from other sources from
      being mistakenly passed to an Ncurses library call.</p>

      <p>Now compile a "hello world" terminal drawing program to
      tie this all together:</p>
      <link rel="import" href="code/ffi/hello/hello.ml"/>

      <p>The <code>hello</code> executable is compiled by linking
      with the <code>ctypes.foreign</code> OCamlfind package:</p>
      <link rel="import" href="code/ffi/hello/jbuild"/>
      <link rel="import" href="code/ffi/hello/build_hello.sh"/>

      <p>Running <code>./hello.native</code> should now display a
      Hello World in your terminal!<idx>Ctypes library/build directives for</idx></p>

      <p>Ctypes wouldn't be very useful if it were limited to only
      defining simple C types, of course. It provides full support
      for C pointer arithmetic, pointer conversions, and reading
      and writing through pointers, using OCaml functions as
      function pointers to C code, as well as struct and union
      definitions.</p>

      <p>We'll go over some of these features in more detail for
      the remainder of the chapter by using some POSIX date
      functions as running examples.<a data-type="indexterm" data-startref="FFItermint">&nbsp;</a></p>
    </section>

    <section id="basic-scalar-c-types" data-type="sect1">
      <h1>Basic Scalar C Types</h1>

      <p>First, let's look at how to define basic scalar C types.
      Every C type is represented by an OCaml equivalent via the
      single type definition:<idx>scalar C types</idx><idx>foreign function interface (FFI)/basic scalar C types</idx></p>
      <link rel="import" href="code/ctypes/ctypes.mli"/>

      <p><code>Ctypes.typ</code> is the type of values that
      represents C types to OCaml. There are two types associated
      with each instance of <code>typ</code>:</p>

      <ul>
        <li>
          <p>The C type used to store and pass values to the
          foreign library.</p>
        </li>

        <li>
          <p>The corresponding OCaml type. The <code>'a</code> type
          parameter contains the OCaml type such that a value of
          type <code>t typ</code> is used to read and write OCaml
          values of type <code>t</code>.</p>
        </li>
      </ul>

      <p>There are various other uses of <code>typ</code> values
      within Ctypes, such as:</p>

      <ul>
        <li>
          <p>Constructing function types for binding native
          functions</p>
        </li>

        <li>
          <p>Constructing pointers for reading and writing
          locations in C-managed storage</p>
        </li>

        <li>
          <p>Describing component fields of structures, unions, and
          arrays</p>
        </li>
      </ul>

      <p>Here are the definitions for most of the standard C99
      scalar types, including some platform-dependent ones:
      <idx>C99 scalar types</idx></p>
      <link rel="import" href="code/ctypes/ctypes.mli" part="1"/>

      <p>These values are all of type <code>'a typ</code>, where
      the value name (e.g., <code>void</code>) tells you the C type
      and the <code>'a</code> component (e.g., <code>unit</code>)
      is the OCaml representation of that C type. Most of the
      mappings are straightforward, but some of them need a bit
      more explanation:</p>

      <ul>
        <li>
          <p>Void values appear in OCaml as the <code>unit</code>
          type. Using <code>void</code> in an argument or result
          type specification produces an OCaml function that
          accepts or returns <code>unit</code>. Dereferencing a
          pointer to <code>void</code> is an error, as in C, and
          will raise the <code>IncompleteType</code> exception.</p>
        </li>

        <li>
          <p>The C <code>size_t</code> type is an alias for one of
          the unsigned integer types. The actual size and alignment
          requirements for <code>size_t</code> varies between
          platforms. Ctypes provides an OCaml <code>size_t</code>
          type that is aliased to the appropriate integer type.</p>
        </li>

        <li>
          <p>OCaml only supports double-precision floating-point
          numbers, and so the C <code>float</code> and
          <code>double</code> types both map onto the OCaml
          <code>float</code> type, and the C <code>float
          complex</code> and <code>double complex</code> types both
          map onto the OCaml double-precision
          <code>Complex.t</code> type.</p>
        </li>
      </ul>
    </section>

    <section id="pointers-and-arrays" data-type="sect1">
      <h1>Pointers and Arrays</h1>

      <p>Pointers are at the heart of C, so they are necessarily
      part of Ctypes, which provides support for pointer
      arithmetic, pointer conversions, reading and writing through
      pointers, and passing and returning pointers to and from
      functions.<idx>POSIX functions</idx> <idx>arrays/pointers and</idx><idx>pointers/support for in Ctypes</idx><idx>foreign function interface (FFI)/pointers and arrays</idx></p>

      <p>We've already seen a simple use of pointers in the Ncurses
      example. Let's start a new example by binding the following
      POSIX functions:</p>
      <link rel="import" href="code/ffi/posix_headers.h"/>

      <p>The <code>time</code> function returns the current
      calendar time and is a simple start. The first step is to
      open some of the Ctypes modules:</p>

      <dl>
        <dt><code>Ctypes</code></dt>

        <dd>
          <p>The <code>Ctypes</code> module provides functions for
          describing C types in OCaml.</p>
        </dd>

        <dt><code>PosixTypes</code></dt>

        <dd>
          <p>The <code>PosixTypes</code> module includes some extra
          POSIX-specific types (such as <code>time_t</code>).</p>
        </dd>

        <dt><code>Foreign</code></dt>

        <dd>
          <p>The <code>Foreign</code> module exposes the
          <code>foreign</code> function that makes it possible to
          invoke C functions.</p>
        </dd>
      </dl>

      <p>We can now create a binding to <code>time</code> directly
      from the toplevel.</p>

      <link rel="import" part="0.5" href="code/ffi/posix.mlt"/>

      <p>The <code>foreign</code> function is the main link between
      OCaml and C. It takes two arguments: the name of the C
      function to bind, and a value describing the type of the
      bound function. In the <code>time</code> binding, the
      function type specifies one argument of type <code>ptr
      time_t</code> and a return type of <code>time_t</code>.</p>

      <p>We can now call <code>time</code> immediately in the same
      toplevel. The argument is actually optional, so we'll just
      pass a null pointer that has been coerced into becoming a
      null pointer to <code>time_t</code>:</p>
      <link rel="import" href="code/ffi/posix.mlt" part="1"/>

      <p>Since we're going to call <code>time</code> a few times,
      let's create a wrapper function that passes the null pointer
      through:</p>
      <link rel="import" href="code/ffi/posix.mlt" part="2"/>

      <p>Since <code>time_t</code> is an abstract type, we can't
      actually do anything useful with it directly. We need to bind
      a second function to do anything useful with the return
      values from <code>time</code>. We'll move on to
      <code>difftime</code>; the second C function in our prototype
      list:</p>
      <link rel="import" href="code/ffi/posix.mlt" part="3"/>

      <p>The binding to <code>difftime</code> above is sufficient
      to compare two <code>time_t</code> values.</p>

      <section id="allocating-typed-memory-for-pointers" data-type="sect2">
        <h2>Allocating Typed Memory for Pointers</h2>

        <p>Let's look at a slightly less trivial example where we
        pass a nonnull pointer to a function. Continuing with the
        theme from earlier, we'll bind to the <code>ctime</code>
        function, which converts a <code>time_t</code> value to a
        human-readable string:<idx>memory/allocation for pointers</idx><idx>pointers/allocating typed memory for</idx></p>
        <link rel="import" href="code/ffi/posix.mlt" part="4"/>

        <p>The binding is continued in the toplevel to add to our
        growing collection. However, we can't just pass the result
        of <code>time</code> to <code>ctime</code>:</p>
        <link rel="import" href="code/ffi/posix.mlt" part="5"/>

        <p>This is because <code>ctime</code> needs a pointer to
        the <code>time_t</code> rather than passing it by value. We
        thus need to allocate some memory for the
        <code>time_t</code> and obtain its memory address:</p>
        <link rel="import" href="code/ffi/posix.mlt" part="6"/>

        <p>The <code>allocate</code> function takes the type of the
        memory to be allocated and the initial value and it returns
        a suitably typed pointer. We can now call
        <code>ctime</code> passing the pointer as an argument:</p>
        <link rel="import" href="code/ffi/posix.mlt" part="7"/>
      </section>

      <section id="using-views-to-map-complex-values" data-type="sect2">
        <h2>Using Views to Map Complex Values</h2>

        <p>While scalar types typically have a 1:1 representation,
        other C types require extra work to convert them into
        OCaml. Views create new C type descriptions that have
        special behavior when used to read or write C values.
        <idx>mapping/complex values with views</idx>
        <idx>values/mapping complex with views</idx></p>

        <p>We've already used one view in the definition of
        <code>ctime</code> earlier. The <code>string</code> view
        wraps the C type <code>char *</code> (written in OCaml as
        <code>ptr char</code>) and converts between the C and OCaml
        string representations each time the value is written or
        read.</p>

        <p>Here is the type signature of the
        <code>Ctypes.view</code> function:</p>
        <link rel="import" href="code/ctypes/ctypes.mli" part="2"/>

        <p>Ctypes has some internal low-level conversion functions
        that map between an OCaml <code>string</code> and a C
        character buffer by copying the contents into the
        respective data structure. They have the following type
        signature:</p>
        <link rel="import" href="code/ctypes/ctypes.mli" part="3"/>

        <p>Given these functions, the definition of the
        <code>Ctypes.string</code> value that uses views is quite
        simple:</p>
        <link rel="import" href="code/ctypes/ctypes_impl.ml"/>

        <p>The type of this <code>string</code> function is a
        normal <code>typ</code> with no external sign of the use of
        the view function:</p>
        <link rel="import" href="code/ctypes/ctypes.mli" part="4"/>

        <div data-type="note">
          <h1>OCaml Strings Versus C Character Buffers</h1>

          <p>Although OCaml strings may look like C character
          buffers from an interface perspective, they're very
          different in terms of their memory representations.</p>

          <p>OCaml strings are stored in the OCaml heap with a
          header that explicitly defines their length. C buffers
          are also fixed-length, but by convention, a C string is
          terminated by a null (a <code>\0</code> byte) character.
          The C string functions calculate their length by scanning
          the buffer until the first null character is
          encountered.</p>

          <p>This means that you need to be careful that OCaml
          strings that you pass to C functions don't contain any
          null values, since the first occurrence of a null
          character will be treated as the end of the C string.
          Ctypes also defaults to a <em>copying</em> interface for
          strings, which means that you shouldn't use them when you
          want the library to mutate the buffer in-place. In that
          situation, use the Ctypes <code>Bigarray</code> support
          to pass memory by reference instead.</p>
        </div>
      </section>
    </section>

    <section id="structs-and-unions" data-type="sect1">
      <h1>Structs and Unions</h1>

      <p>The C constructs <code>struct</code> and
      <code>union</code> make it possible to build new types from
      existing types. Ctypes contains counterparts that work
      similarly.<idx data-see="structs and unions">unions</idx><idx>structs and unions/structure definition</idx><idx>foreign function interface (FFI)/structs and unions</idx></p>

      <section id="defining-a-structure" data-type="sect2">
        <h2>Defining a Structure</h2>

        <p>Let's improve the timer function that we wrote earlier.
        The POSIX function <code>gettimeofday</code> retrieves the
        time with microsecond resolution. The signature of
        <code>gettimeofday</code> is as follows, including the
        structure definitions:</p>
        <link rel="import" href="code/ffi/timeval_headers.h"/>

        <p>Using Ctypes, we can describe this type as follows in
        our toplevel, continuing on from the previous
        definitions:</p>
        <link rel="import" href="code/ffi/posix.mlt" part="8"/>

        <p>The first command defines a new OCaml type
        <code>timeval</code> that we'll use to instantiate the
        OCaml version of the struct. This is a <em>phantom
        type</em> that exists only to distinguish the underlying C
        type from other pointer types. The particular
        <code>timeval</code> structure now has a distinct type from
        other structures we define elsewhere, which helps to avoid
        getting them mixed up.</p>

        <p>The second command calls <code>structure</code> to
        create a fresh structure type. At this point, the structure
        type is incomplete: we can add fields but cannot yet use it
        in <code>foreign</code> calls or use it to create
        values.</p>
      </section>

      <section id="adding-fields-to-structures" data-type="sect2">
        <h2>Adding Fields to Structures</h2>

        <p>The <code>timeval</code> structure definition still
        doesn't have any fields, so we need to add those next:
        <idx>fields/adding to structures</idx>
        <idx>structs and unions/field addition</idx></p>
        <link rel="import" href="code/ffi/posix.mlt" part="9"/>

        <p>The <code>field</code> function appends a field to the
        structure, as shown with <code>tv_sec</code> and
        <code>tv_usec</code>. Structure fields are typed accessors
        that are associated with a particular structure, and they
        correspond to the labels in C.</p>

        <p>Every field addition mutates the structure variable and
        records a new size (the exact value of which depends on the
        type of the field that was just added). Once we
        <code>seal</code> the structure, we will be able to create
        values using it, but adding fields to a sealed structure is
        an error.</p>
      </section>

      <section id="incomplete-structure-definitions" data-type="sect2">
        <h2>Incomplete Structure Definitions</h2>

        <p>Since <code>gettimeofday</code> needs a <code>struct
        timezone</code> pointer for its second argument, we also
        need to define a second structure type: <idx>structs and unions/incomplete structure definitions</idx></p>
        <link rel="import" href="code/ffi/posix.mlt" part="10"/>

        <p>We don't ever need to create <code>struct
        timezone</code> values, so we can leave this struct as
        incomplete without adding any fields or sealing it. If you
        ever try to use it in a situation where its concrete size
        needs to be known, the library will raise an
        <code>IncompleteType</code> exception.</p>

        <p>We're finally ready to bind to <code>gettimeofday</code>
        now:</p>
        <link rel="import" href="code/ffi/posix.mlt" part="11"/>

        <p>There's one other new feature here: the
        <code>returning_checking_errno</code> function behaves like
        <code>returning</code>, except that it checks whether the
        bound C function modifies the C error flag. Changes to
        <code>errno</code> are mapped into OCaml exceptions and
        raise a <code>Unix.Unix_error</code> exception just as the
        standard library functions do.</p>

        <p>As before, we can create a wrapper to make
        <code>gettimeofday</code> easier to use. The functions
        <code>make</code>, <code>addr</code>, and <code>getf</code>
        create a structure value, retrieve the address of a
        structure value, and retrieve the value of a field from a
        structure:</p>
        <link rel="import" href="code/ffi/posix.mlt" part="12"/>

        <p>You need to be a little careful not to get all the open
        modules mixed up here. Both <code>Pervasives</code> and
        <code>Ctypes</code> define different <code>float</code>
        functions. The <code>Ctypes</code> module we opened up
        earlier overrides the <code>Pervasives</code> definition.
        As seen previously though, you just need to locally open
        <code>Pervasives</code> again to bring the usual
        <code>float</code> function back in scope.</p>

        <section id="recap-a-time-printing-command" data-type="sect3">
          <h3>Recap: A time-printing command</h3>

          <p>We built up a lot of bindings in the previous section,
          so let's recap them with a complete example that ties it
          together with a command-line frontend: <idx>structs and unions/time-printing command</idx></p>
          <link rel="import" href="code/ffi/datetime/datetime.ml"/>

          <p>This can be compiled and run in the usual way:
          <idx>returning function</idx></p>
          <link rel="import" href="code/ffi/datetime/jbuild"/>
          <link rel="import" href="code/ffi/datetime/build_datetime.sh"/>

          <aside data-type="sidebar">
            <h5>Why Do We Need to Use returning?</h5>

            <p>The alert reader may be curious about why all these
            function definitions have to be terminated by
            <code>returning</code>:</p>
            <link rel="import" href="code/ffi/return_frag.ml"/>

            <p>The <code>returning</code> function may appear
            superfluous here. Why couldn't we simply give the types
            as follows?</p>
            <link rel="import" href="code/ffi/return_frag.ml" part="1"/>

            <p>The reason involves higher types and two differences
            between the way that functions are treated in OCaml and
            C. Functions are first-class values in OCaml, but not
            in C. For example, in C it is possible to return a
            function pointer from a function, but not to return an
            actual function.</p>

            <p>Secondly, OCaml functions are typically defined in a
            curried style. The signature of a two-argument function
            is written as follows:</p>
            <link rel="import" href="code/ffi/return_frag.ml" part="2"/>

            <p>but this really means:</p>
            <link rel="import" href="code/ffi/return_frag.ml" part="3"/>

            <p>and the arguments can be supplied one at a time to
            create a closure. In contrast, C functions receive
            their arguments all at once. The equivalent C function
            type is the following:</p>
            <link rel="import" href="code/ffi/return_c_frag.h"/>

            <p>and the arguments must always be supplied
            together:</p>
            <link rel="import" href="code/ffi/return_c_frag.c"/>

            <p>A C function that's written in curried style looks
            very different:</p>
            <link rel="import" href="code/ffi/return_c_uncurried.c"/>

            <p>The OCaml type of <code>uncurried_C</code> when
            bound by Ctypes is <code>int -&gt; int -&gt;
            int</code>: a two-argument function. The OCaml type of
            <code>curried_C</code> when bound by
            <code>ctypes</code> is <code>int -&gt; (int -&gt;
            int)</code>: a one-argument function that returns a
            one-argument function.</p>

            <p>In OCaml, of course, these types are absolutely
            equivalent. Since the OCaml types are the same but the
            C semantics are quite different, we need some kind of
            marker to distinguish the cases. This is the purpose of
            <code>returning</code> in function definitions.</p>
          </aside>
        </section>
      </section>

      <section id="defining-arrays" data-type="sect2">
        <h2>Defining Arrays</h2>

        <p>Arrays in C are contiguous blocks of the same type of
        value. Any of the basic types defined previously can be
        allocated as blocks via the <code>Array</code> module:
        <idx>arrays/definition of</idx><idx>structs and unions/array definition</idx></p>
        <link rel="import" href="code/ctypes/ctypes.mli" part="5"/>

        <p>The array functions are similar to those in the standard
        library <code>Array</code> module except that they operate
        on arrays stored using the flat C representation rather
        than the OCaml representation described in <a href="20-runtime-memory-layout.html#memory-representation-of-values" data-type="xref">Memory Representation Of Values</a>.</p>

        <p>As with standard OCaml arrays, the conversion between
        arrays and lists requires copying the values, which can be
        expensive for large data structures. Notice that you can
        also convert an array into a <code>ptr</code> pointer to
        the head of the underlying buffer, which can be useful if
        you need to pass the pointer and size arguments separately
        to a C function.</p>

        <p>Unions in C are named structures that can be mapped onto
        the same underlying memory. They are also fully supported
        in Ctypes, but we won't go into more detail here.
        <idx>operators/controlling pointers</idx>
        <idx>pointers/operators controlling</idx></p>

        <aside data-type="sidebar">
          <h5>Pointer Operators for Dereferencing and
          Arithmetic</h5>

          <p>Ctypes defines a number of operators that let you
          manipulate pointers and arrays just as you would in C.
          The Ctypes equivalents do have the benefit of being more
          strongly typed, of course (see <a href="19-foreign-function-interface.html#Table19sub1" data-type="xref">Table19sub1</a>).</p>

          <table id="Table19sub1">
            <caption>
              Operators for manipulating pointers and arrays
            </caption>

            <thead>
              <tr>
                <th>Operator</th>

                <th>Purpose</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><code>!@ p</code></td>

                <td>Dereference the pointer <code>p</code>.</td>
              </tr>

              <tr>
                <td><code>p &lt;-@ v</code></td>

                <td>Write the value <code>v</code> to the address
                <code>p</code>.</td>
              </tr>

              <tr>
                <td><code>p +@ n</code></td>

                <td>If <code>p</code> points to an array element,
                then compute the address of the <code>n</code>th
                next element.</td>
              </tr>

              <tr>
                <td><code>p -@ n</code></td>

                <td>If <code>p</code> points to an array element,
                then compute the address of the <code>n</code>th
                previous element.</td>
              </tr>
            </tbody>
          </table>

          <p>There are also other useful nonoperator functions
          available (see the Ctypes documentation), such as pointer
          differencing and comparison.</p>
        </aside>
      </section>
    </section>

    <section id="passing-functions-to-c" data-type="sect1">
      <h1>Passing Functions to C</h1>

      <p>It's also straightforward to pass OCaml function values to
      C. The C standard library function <code>qsort</code> sorts
      arrays of elements using a comparison function passed in as a
      function pointer. The signature for <code>qsort</code>
      is:<idx>functions/passing to C</idx> <idx>foreign function interface (FFI)/passing functions to C</idx></p>
      <link rel="import" href="code/ffi/qsort/qsort.h"/>

      <p>C programmers often use <code>typedef</code> to make type
      definitions involving function pointers easier to read. Using
      a typedef, the type of <code>qsort</code> looks a little more
      palatable:</p>
      <link rel="import" href="code/ffi/qsort/qsort_typedef.h"/>

      <p>This also happens to be a close mapping to the
      corresponding Ctypes definition. Since type descriptions are
      regular values, we can just use <code>let</code> in place of
      <code>typedef</code> and end up with working OCaml bindings
      to <code>qsort</code>:</p>

      <link rel="import" part="1" href="code/ffi/qsort.mlt"/>

      <p>We only use <code>compare_t</code> once (in the
      <code>qsort</code> definition), so you can choose to inline
      it in the OCaml code if you prefer. As the type shows, the
      resulting <code>qsort</code> value is a higher-order
      function, since the fourth argument is itself a function. As
      before, let's define a wrapper function to make
      <code>qsort</code> easier to use. The second and third
      arguments to <code>qsort</code> specify the length (number of
      elements) of the array and the element size.</p>

      <p>Arrays created using Ctypes have a richer runtime
      structure than C arrays, so we don't need to pass size
      information around. Furthermore, we can use OCaml
      polymorphism in place of the unsafe <code>void ptr</code>
      type.</p>

      <section id="example-a-command-line-quicksort" data-type="sect2">
        <h2>Example: A Command-Line Quicksort</h2>

        <p>The following is a command-line tool that uses the
        <code>qsort</code> binding to sort all of the integers
        supplied on the standard input: <idx>qsort binding</idx></p>
        <link rel="import" href="code/ffi/qsort/qsort.ml"/>

        <p>Compile it in the usual way with <em>dune</em> and
        test it against some input data, and also build the
        inferred interface so we can examine it more closely:</p>
        <link rel="import" href="code/ffi/qsort/jbuild"/>
        <link rel="import" href="code/ffi/qsort/build_qsort.sh"/>

        <p>The inferred interface shows us the types of the raw
        <code>qsort</code> binding and also the <code>qsort'</code>
        wrapper function:</p>
        <link rel="import" href="code/ffi/qsort/qsort.mli"/>

        <p>The <code>qsort'</code> wrapper function has a much more
        canonical OCaml interface than the raw binding. It accepts
        a comparator function and a Ctypes array, and returns the
        same Ctypes array. It's not strictly required that it
        returns the array, since it modifies it in-place, but it
        makes it easier to chain the function using the
        <code>|&gt;</code> operator (as <code>sort_stdin</code>
        does in the example).</p>

        <p>Using <code>qsort'</code> to sort arrays is
        straightforward. Our example code reads the standard input
        as a list, converts it to a C array, passes it through
        qsort, and outputs the result to the standard output.
        Again, remember to not confuse the
        <code>Ctypes.Array</code> module with the
        <code>Core.Array</code> module: the former is in scope
        since we opened <code>Ctypes</code> at the start of the
        file.<idx>memory/and allocated Ctypes</idx>
        <idx>Ctypes library/lifetime of allocated Ctypes</idx><idx>garbage collection/of allocated Ctypes</idx></p>

        <aside data-type="sidebar">
          <h5>Lifetime of Allocated Ctypes</h5>

          <p>Values allocated via Ctypes (i.e., using
          <code>allocate</code>, <code>Array.make</code>, and so
          on) will not be garbage-collected as long as they are
          reachable from OCaml values. The system memory they
          occupy is freed when they do become unreachable, via a
          finalizer function registered with the garbage collector
          (GC).</p>

          <p>The definition of reachability for Ctypes values is a
          little different from conventional OCaml values, though.
          The allocation functions return an OCaml-managed pointer
          to the value, and as long as some derivative pointer is
          still reachable by the GC, the value won't be
          collected.</p>

          <p>"Derivative" means a pointer that's computed from the
          original pointer via arithmetic, so a reachable reference
          to an array element or a structure field protects the
          whole object from collection.</p>

          <p>A corollary of the preceding rule is that pointers
          written into the C heap don't have any effect on
          reachability. For example, if you have a C-managed array
          of pointers to structs, then you'll need some additional
          way of keeping the structs themselves around to protect
          them from collection. You could achieve this via a global
          array of values on the OCaml side that would keep them
          live until they're no longer needed.</p>

          <p>Functions passed to C have similar considerations
          regarding lifetime. On the OCaml side, functions created
          at runtime may be collected when they become unreachable.
          As we've seen, OCaml functions passed to C are converted
          to function pointers, and function pointers written into
          the C heap have no effect on the reachability of the
          OCaml functions they reference. With <code>qsort</code>
          things are straightforward, since the comparison function
          is only used during the call to <code>qsort</code>
          itself. However, other C libraries may store function
          pointers in global variables or elsewhere, in which case
          you'll need to take care that the OCaml functions you
          pass to them aren't prematurely garbage-collected.</p>
        </aside>
      </section>
    </section>

    <section id="learning-more-about-c-bindings" data-type="sect1">
      <h1>Learning More About C Bindings</h1>

      <p>The Ctypes <a href="http://github.com/ocamllabs/ocaml-ctypes">distribution</a>
      contains a number of larger-scale examples, including:
      <idx>foreign function interface (FFI)/C bindings</idx></p>

      <ul>
        <li>
          <p>Bindings to the POSIX <code>fts</code> API, which
          demonstrates C callbacks more comprehensively</p>
        </li>

        <li>
          <p>A more complete Ncurses binding than the example we
          opened the chapter with</p>
        </li>

        <li>
          <p>A comprehensive test suite that covers the complete
          library, and can provide useful snippets for your own
          bindings</p>
        </li>
      </ul>

      <p>This chapter hasn't really needed you to understand the
      innards of OCaml at all. Ctypes does its best to make
      function bindings easy, but the rest of this part will also
      fill you in about interactions with OCaml memory layout in
      <a href="20-runtime-memory-layout.html#memory-representation-of-values" data-type="xref">Memory Representation Of Values</a> and
      automatic memory management in <a href="21-garbage-collector.html#understanding-the-garbage-collector" data-type="xref">Understanding The Garbage Collector</a>.</p>

      <p>Ctypes gives OCaml programs access to the C representation
      of values, shielding you from the details of the OCaml value
      representation, and introduces an abstraction layer that
      hides the details of foreign calls. While this covers a wide
      variety of situations, it's sometimes necessary to look
      behind the abstraction to obtain finer control over the
      details of the interaction between the two languages.</p>

      <p>You can find more information about the C interface in
      several places:</p>

      <ul>
        <li>
          <p>The standard OCaml foreign function interface allows
          you to glue OCaml and C together from the other side of
          the boundary, by writing C functions that operate on the
          OCaml representation of values. You can find details of
          the standard interface in the <a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual033.html">
          OCaml manual</a> and in the book <a href="http://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf">
          <em>Developing Applications with Objective
          Caml</em></a>.</p>
        </li>

        <li>
          <p>Florent Monnier maintains an excellent online <a href="http://www.linux-nantes.org/~fmonnier/ocaml/ocaml-wrapping-c.html">
          OCaml</a> that provides examples of how to call OCaml
          functions from C. This covers a wide variety of OCaml
          data types and also more complex callbacks between C and
          OCaml.</p>
        </li>

        <li>
          <p><a href="http://www.swig.org">SWIG</a> is a tool that
          connects programs written in C/C++ to a variety of
          higher-level programming languages, including OCaml. The
          SWIG manual has examples of converting library
          specifications into OCaml bindings.</p>
        </li>
      </ul>

      <section id="struct-memory-layout" data-type="sect2">
        <h2>Struct Memory Layout</h2>

        <p>The C language gives implementations a certain amount of
        freedom in choosing how to lay out structs in memory. There
        may be padding between members and at the end of the
        struct, in order to satisfy the memory alignment
        requirements of the host platform. Ctypes uses
        platform-appropriate size and alignment information to
        replicate the struct layout process. OCaml and C will have
        consistent views about the layout of the struct as long as
        you declare the fields of a struct in the same order and
        with the same types as the C library you're binding to.
        <idx>memory/layout for structs</idx>
        <idx>structs and unions/memory layout of</idx></p>

        <p>However, this approach can lead to difficulties when the
        fields of a struct aren't fully specified in the interface
        of a library. The interface may list the fields of a
        structure without specifying their order, or make certain
        fields available only on certain platforms, or insert
        undocumented fields into struct definitions for performance
        reasons. For example, the <code>struct timeval</code>
        definition used in this chapter accurately describes the
        layout of the struct on common platforms, but
        implementations on some more unusual architectures include
        additional padding members that will lead to strange
        behavior in the examples.</p>

        <p>The Cstubs subpackage of Ctypes addresses this issue.
        Rather than simply assuming that struct definitions given
        by the user accurately reflect the actual definitions of
        structs used in C libraries, Cstubs generates code that
        uses the C library headers to discover the layout of the
        struct. The good news is that the code that you write
        doesn't need to change much. Cstubs provides alternative
        implementations of the <code>field</code> and
        <code>seal</code> functions that you've already used to
        describe <code>struct timeval</code>; instead of computing
        member offsets and sizes appropriate for the platform,
        these implementations obtain them directly from C.</p>

        <p>The details of using Cstubs are available in the online
        <a href="https://ocamllabs.github.io/ocaml-ctypes">documentation</a>,
        along with instructions on integration with <span class="command"><em>autoconf</em></span> platform portability
        instructions.<a data-type="indexterm" data-startref="INTERffi">&nbsp;</a></p>
      </section>
    </section>
  </section>
</body>
</html>
