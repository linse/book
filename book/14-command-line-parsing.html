<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy for HTML5 for Mac OS X version 4.9.20"/>

    <title></title>
  </head>

  <body>
    <section xmlns="http://www.w3.org/1999/xhtml" id="command-line-parsing" data-type="chapter">
      <h1>Command-Line Parsing</h1>

      <p>
	Many of the OCaml programs that you'll write will end up as
	binaries that need to be run from a command prompt. Any
	nontrivial command line should support a collection of basic
	features:</p>

      <ul><li><p>
	    Parsing of command-line arguments</p></li>

	<li> <p>
	    Generation of error messages in response to incorrect
            inputs</p></li>

	<li> <p>
	    Help for all the available options </p> </li>

	<li> <p>
	    Interactive autocompletion</p> </li>
      </ul>

      <p>
	It's tedious and error-prone to code all of this manually
	for every program you write. Core provides the Command library,
	which simplifies all of this by letting you declare all your
	command-line options in one place and by deriving all of the
	above functionality from these declarations.

	<idx>command-line parsing/Command library for</idx></p>

      <p>
	Command is simple to use for simple applications but also
	scales well as your needs grow more complex. In particular,
	Command provides a sophisticated subcommand mode that groups
	related commands together as the complexity of your user
	interface grows. You may already be familiar with this
	command-line style from the Git or Mercurial version control
	systems.</p>

      <p>
	In this chapter, we'll:</p>

      <ul>
	<li>
          <p>
	    Learn how to use Command to construct basic and grouped
            command-line interfaces</p>
	</li>

	<li>
          <p>
	    We will build simple equivalents to the cryptographic
            <code>md5</code> and <code>shasum</code> utilities</p>
	</li>

	<li>
          <p>
	    Demonstrate how <em>functional combinators</em> can be
            used to declare complex command-line interfaces in a
            type-safe and elegant way

	    <idx>combinators/functional combinators</idx></p>
	</li>
      </ul>

      <section id="basic-command-line-parsing" data-type="sect1">
	<h1>Basic Command-Line Parsing</h1>

	<p>
	  Let's start by working through a clone of the
	  <em>md5sum</em> command that is present on most Linux
	  installations (the equivalent command on Mac OS X is simply
	  <code>md5</code>). The following function defined below reads
	  in the contents of a file, applies the MD5 one-way
	  cryptographic hash function to the data, and outputs an ASCII
	  hex representation of the result:

	  <idx>MD5 one-way cryptographic hash function</idx>
	  <idx>command-line parsing/basic approach to</idx></p>

	<link rel="import" href="code/command-line-parsing/basic_md5/basic_md5.ml"/>

	<p>
	  The <code>do_hash</code> function accepts a
	  <code>filename</code> parameter and prints the human-readable
	  MD5 string to the console standard output. The first step
	  toward turning this function into a command-line program is
	  to declare all the possible command-line arguments in a
	  <em>specification</em>. <code>Command.Spec</code> defines
	  combinators that can be chained together to define optional
	  flags and positional arguments, what types they should map
	  to, and whether to take special actions (such as pausing for
	  interactive input) if certain inputs are encountered.</p>

	<section id="anonymous-arguments" data-type="sect2">
          <h2>Anonymous Arguments</h2>

          <p>
	    Let's build the specification for a single argument that
            is passed directly on the command line. This is known as
            an <em>anonymous</em> argument:

	    <idx>arguments/anonymous arguments</idx>
	    <idx>anonymous arguments</idx></p>

          <link rel="import" href="code/command-line-parsing/basic_md5/basic_md5.ml" part="1"/>

          <p>
	    The <code>Command.Spec</code> module defines the tools
            you'll need to build up a command-line specification. We
            start with the <code>empty</code> value and add parameters
            to that using the <code>+&gt;</code> combinator. (Both of
            these values come from <code>Command.Spec</code>.)</p>

          <p>
	    In this case, we defined a single anonymous argument
            called <code>filename</code>, which takes a value of type
            <code>string</code>. Anonymous parameters are created using
            the <code>%:</code> operator, which binds a textual name
            (used in the help text to identify the parameter) to an
            OCaml conversion function that parses the command-line
            string fragments into a higher-level OCaml data type. In
            the preceding example, this is just
            <code>Command.Spec.string</code>, but we'll see more
            complex conversion options later in the chapter.</p>
	</section>

	<section id="defining-basic-commands" data-type="sect2">
          <h2>Defining Basic Commands</h2>

          <p>
	    Once we've defined a specification, we need to put it to
            work on real input. The simplest way is to directly create
            a command-line interface via the <code>Command.basic</code>
            module:

	    <idx>Command.basic module</idx></p>

          <link rel="import" href="code/command-line-parsing/basic_md5/basic_md5.ml" part="2"/>

          <p>
	    <code>Command.basic</code> defines a complete
            command-line interface that takes the following extra
            arguments, in addition to the ones defined in the
            specification:</p>

          <dl>
            <dt><code>summary</code></dt>

            <dd>
              <p>
		A required one-line description to go at the top of
		the command help screen.</p>
            </dd>

            <dt><code>readme</code></dt>

            <dd>
              <p>
		For longer help text when the command is called with
		<code>-help</code>. The <code>readme</code> argument is
		a function that is only evaluated when the help text is
		actually needed.</p>
            </dd>
          </dl>

          <p>
	    The specification and the callback function follow as
            nonlabeled arguments.</p>

          <p>
	    The callback function is where all the work happens
            after the command-line parsing is complete. This function
            is applied with the arguments containing the parsed
            command-line values, and it takes over as the main thread
            of the application. The callback's arguments are passed in
            the same order as they were bound in the specification
            (using the <code>+&gt;</code> operator).

	    <idx>arguments/unit argument to callbacks</idx>
	    <idx>unit argument</idx>
	    <idx>callback function</idx></p>

          <div data-type="note">
            <h1>The Extra unit Argument to Callbacks</h1>

            <p>
	      The preceding callback needs an extra
              <code>unit</code> argument after <code>filename</code>.
              This is to ensure that specifications can work even when
              they are empty (i.e. the <code>Command.Spec.empty</code>
              value).</p>

            <p>
	      Every OCaml function needs at least one argument, so
              the final <code>unit</code> guarantees that it will not
              be evaluated immediately as a value if there are no other
              arguments.</p>
          </div>
	</section>

	<section id="running-basic-commands" data-type="sect2">
          <h2>Running Basic Commands</h2>

          <p>
	    Once we've defined the basic command, running it is just
            one function call away:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5/basic_md5.ml" part="3"/>

          <p>
	    <code>Command.run</code> takes a couple of optional
            arguments that are useful to identify which version of the
            binary you are running in production. You'll need to
            install Cryptokit via <code>opam install cryptokit</code>
            before building this example. Once that's completed, run
            the following to compile the binary:</p>
          <link rel="import" href="code/command-line-parsing/basic_md5/jbuild"/>
          <link rel="import" href="code/command-line-parsing/basic_md5/basic_md5.sh" part="build"/>

          <p>
	    You can now query the version information for the binary
            you just compiled:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5/basic_md5.sh" part="get version"/>

          <p>
	    The versions that you see in the output were defined via
            the optional arguments to <code>Command.run</code>. You can
            leave these blank in your own programs or get your build
            system to generate them directly from your version control
            system (e.g., by running <code>hg id</code> to generate a
            build revision number, in the case of Mercurial):</p>

          <link rel="import" href="code/command-line-parsing/basic_md5/basic_md5.sh" part="get help"/>

          <p>
	    When we invoke this binary without any arguments, it
            helpfully displays all of the command-line options
            available, along with a message to the standard error that
            informs you that a required argument <code>filename</code>
            is missing.</p>

          <p>
	    If you do supply the <code>filename</code> argument,
            then <code>do_hash</code> is called with the argument and
            the MD5 output is displayed to the standard output:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5/basic_md5.sh" part="run"/>

          <p>
	    And that's all it took to build our little MD5 utility!
            Here's a complete version of the example we just walked
            through, made slightly more succinct by removing
            intermediate variables:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5_succinct.ml"/>

          <p>
	    Now that we have the basics in place, the rest of the
            chapter will examine some of the more advanced features of
            Command.</p>
	</section>
      </section>

      <section id="argument-types" data-type="sect1">
	<h1>Argument Types</h1>

	<p>
	  You aren't just limited to parsing command lines as
	  strings, of course. <code>Command.Spec</code> defines several
	  other conversion functions (shown in <a href="14-command-line-parsing.html#table14_1" data-type="xref">Table14_1</a>) that validate and parse input into
	  various types.

	  <idx>arguments/argument types</idx>
	  <idx>command-line parsing/argument types</idx></p>

	<table id="table14_1">
          <caption>
            Conversion functions defined by <code>Command.spec</code>
          </caption>

          <thead>
            <tr>
              <th>Argument type</th>

              <th>OCaml type</th>

              <th>Example</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><code>string</code></td>

              <td><code>string</code></td>

              <td><code>foo</code></td>
            </tr>

            <tr>
              <td><code>int</code></td>

              <td><code>int</code></td>

              <td><code>123</code></td>
            </tr>

            <tr>
              <td><code>float</code></td>

              <td><code>float</code></td>

              <td><code>123.01</code></td>
            </tr>

            <tr>
              <td><code>bool</code></td>

              <td><code>bool</code></td>

              <td><code>true</code></td>
            </tr>

            <tr>
              <td><code>date</code></td>

              <td><code>Date.t</code></td>

              <td><code>2013-12-25</code></td>
            </tr>

            <tr>
              <td><code>time_span</code></td>

              <td><code>Span.t</code></td>

              <td><code>5s</code></td>
            </tr>

            <tr>
              <td><code>file</code></td>

              <td><code>string</code></td>

              <td><code>/etc/passwd</code></td>
            </tr>
          </tbody>
	</table>

	<p>
	  We can tighten up the specification of the command to
	  <code>file</code> to reflect that the argument must be a
	  valid filename, and not just any string:</p>

	<link rel="import" href="code/command-line-parsing/basic_md5_as_filename/basic_md5_as_filename.ml" part="1"/>

	<p>
	  Running this with a nonexistent filename will now output
	  an error if the file doesn't exist. As a bonus, it also
	  enables interactive command-line completion to work on the
	  filename argument (explained later in the chapter):</p>

	<link rel="import" href="code/command-line-parsing/basic_md5_as_filename/run_basic_md5_as_filename.errsh"/>

	<section id="defining-custom-argument-types" data-type="sect2">
          <h2>Defining Custom Argument Types</h2>

          <p>
	    We can also define our own argument types if the
            predefined ones aren't sufficient. For instance, let's make
            a <code>regular_file</code> argument type that ensures that
            the input file isn't a character device or some other odd
            UNIX file type that can't be fully read:

	    <idx>arguments/defining custom types</idx></p>

          <link rel="import" href="code/command-line-parsing/basic_md5_with_custom_arg/basic_md5_with_custom_arg.ml"/>

          <p>
	    The <code>regular_file</code> function transforms a
            <code>filename</code> string parameter into the same string
            but first checks that the file exists and is a regular file
            type. When you build and run this code, you will see the
            new error messages if you try to open a special device such
            as <code>/dev/null</code>:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5_with_custom_arg/run_basic_md5_with_custom_arg.errsh"/>
        </section>

	<section id="optional-and-default-arguments" data-type="sect2">
          <h2>Optional and Default Arguments</h2>

          <p>
	    A more realistic MD5 binary could also read from the
            standard input if a <code>filename</code> isn't
            specified:

	    <idx>arguments/default arguments</idx>
	    <idx>default arguments</idx>
	    <idx>optional arguments/and default arguments</idx>
	    <idx>arguments/optional arguments</idx></p>

          <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file_broken/basic_md5_with_optional_file_broken.ml" part="1"/>

          <p>
	    This just wraps the <code>filename</code> argument
            declaration in the <code>maybe</code> function to mark it
            as an optional argument. However, building this results in
            a compile-time error:</p>
          <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file_broken/jbuild"/>
          <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file_broken/build_basic_md5_with_optional_file_broken.errsh"/>

          <p>
	    This is because changing the argument type has also
            changed the type of the callback function. It now wants a
            <code>string option</code> instead of a
            <code>string</code>, since the value has become optional.
            We can adapt our example to use the new information and
            read from standard input if no file is specified:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/basic_md5_with_optional_file.ml"/>

          <p>
	    The <code>filename</code> parameter to
            <code>do_hash</code> is now a <code>string option</code>
            type. This is resolved into an input channel via
            <code>get_inchan</code> to determine whether to open the
            standard input or a file, and then the rest of the command
            is similar to our previous examples.</p>

          <p>
	    Another possible way to handle this would be to supply a
            dash as the default filename if one isn't specified. The
            <code>maybe_with_default</code> function can do just this,
            with the benefit of not having to change the callback
            parameter type (which may be a problem in more complex
            applications).</p>

          <p>
	    The following example behaves exactly the same as the
            previous example, but replaces <code>maybe</code> with
            <code>maybe_with_default</code>:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/basic_md5_with_default_file.ml"/>

          <p>
	    Building and running both against a system file confirms
            that they have the same behavior:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/jbuild"/>
          <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/basic_and_default_md5.sh" part="build"/>
          <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/basic_and_default_md5.sh" part="run"/>
        </section>

	<section id="sequences-of-arguments" data-type="sect2">
          <h2>Sequences of Arguments</h2>

          <p>
	    One last transformation that's useful is to obtain lists
            of anonymous arguments rather than a single one. As an
            example, let's modify our MD5 code to take a collection of
            files to process on the command line:

	    <idx>arguments/sequences of</idx></p>

          <link rel="import" href="code/command-line-parsing/basic_md5_sequence.ml"/>

          <p>
	    The callback function is a little more complex now, to
            handle the extra options. The <code>files</code> are now a
            <code>string list</code>, and an empty list reverts to
            using standard input, just as our previous
            <code>maybe</code> and <code>maybe_with_default</code>
            examples did. If the list of files isn't empty, then it
            opens up each file and runs them through
            <code>do_hash</code> sequentially.</p>
	</section>
      </section>

      <section id="adding-labeled-flags-to-the-command-line" data-type="sect1">
	<h1>Adding Labeled Flags to the Command Line</h1>

	<p>
	  You aren't just limited to anonymous arguments on the
	  command line. A <em>flag</em> is a named field that can be
	  followed by an optional argument. These flags can appear in
	  any order on the command line, or multiple times, depending
	  on how they're declared in the specification.

	  <idx>flags</idx>
	  <idx>command-line parsing/labeled flags and</idx></p>

	<p>
	  Let's add two arguments to our <code>md5</code> command
	  that mimics the Mac OS X version. A <code>-s</code> flag
	  specifies the string to be hashed directly on the command
	  line and <code>-t</code> runs a self-test. The complete
	  example follows:</p>

	TODO: build_basic_md5_with_flags.sh
  <link rel="import" href="code/command-line-parsing/basic_md5_with_flags/jbuild"/>
	<link rel="import" href="code/command-line-parsing/basic_md5_with_flags/basic_md5_with_flags.sh" part="build"/>
	<link rel="import" href="code/command-line-parsing/basic_md5_with_flags/basic_md5_with_flags.ml"/>

	<p>
	  The specification now uses the <code>flag</code> function
	  to define the two new labeled, command-line arguments. The
	  <code>doc</code> string is formatted so that the first word
	  is the short name that appears in the usage text, with the
	  remainder being the full help text. Notice that the
	  <code>-t</code> flag has no argument, and so we prepend its
	  <code>doc</code> text with a blank space. The help text for
	  the preceding code looks like this:</p>

	<link rel="import" href="code/command-line-parsing/basic_md5_with_flags/basic_md5_with_flags.sh" part="run"/>

	<p>
	  The <code>-s</code> flag in our specification requires a
	  <code>string</code> argument and isn't optional. The Command
	  parser outputs an error message if the flag isn't supplied,
	  as with the anonymous arguments in earlier examples. <a href="14-command-line-parsing.html#table14-2" data-type="xref">Table14 2</a> contains a list of some of the functions
	  that you can wrap flags in to control how they are
	  parsed.

	  <idx>flag functions</idx></p>

	<table id="table14-2">
          <caption>
            Flag functions
          </caption>

          <thead>
            <tr>
              <th>Flag function</th>

              <th>OCaml type</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><code>required</code> <em>arg</em></td>

              <td><em>arg</em> and error if not present</td>
            </tr>

            <tr>
              <td><code>optional</code> <em>arg</em></td>

              <td><em>arg</em> <code>option</code></td>
            </tr>

            <tr>
              <td><code>optional_with_default</code> <em>val</em>
		<em>arg</em></td>

              <td><em>arg</em> with default <em>val</em> if not
		present</td>
            </tr>

            <tr>
              <td><code>listed</code> <em>arg</em></td>

              <td><em>arg</em> <code>list</code>, flag may appear
		multiple times</td>
            </tr>

            <tr>
              <td><code>no_arg</code></td>

              <td><code>bool</code> that is true if flag is
		present</td>
            </tr>
          </tbody>
	</table>

	<p>
	  The flags affect the type of the callback function in
	  exactly the same way as anonymous arguments do. This lets you
	  change the specification and ensure that all the callback
	  functions are updated appropriately, without runtime
	  errors.</p>
      </section>

      <section id="grouping-sub-commands-together" data-type="sect1">
	<h1>Grouping Subcommands Together</h1>

	<p>
	  You can get pretty far by using flags and anonymous
	  arguments to assemble complex, command-line interfaces. After
	  a while, though, too many options can make the program very
	  confusing for newcomers to your application. One way to solve
	  this is by grouping common operations together and adding
	  some hierarchy to the command-line interface.

	  <idx>subcommands, grouping of</idx>
	  <idx>OPAM package manager</idx>
	  <idx>command-line parsing/subcommand grouping</idx></p>

	<p>
	  You'll have run across this style already when using the
	  OPAM package manager (or, in the non-OCaml world, the Git or
	  Mercurial commands). OPAM exposes commands in this form:</p>

	<link rel="import" href="code/command-line-parsing/opam.rawsh"/>

	<p>
	  The <code>config</code>, <code>remote</code>, and
	  <code>install</code> keywords form a logical grouping of
	  commands that factor out a set of flags and arguments. This
	  lets you prevent flags that are specific to a particular
	  subcommand from leaking into the general configuration
	  space.

	  <idx>install keyword</idx>
	  <idx>remote keyword</idx></p>

	<p>
	  This usually only becomes a concern when your application
	  organically grows features. Luckily, it's simple to extend
	  your application to do this in Command: just swap the
	  <code>Command.basic</code> for <code>Command.group</code>,
	  which takes an association list of specifications and handles
	  the subcommand parsing and help output for you:

	  <idx>Command.group</idx></p>

	<link rel="import" href="code/command-line-parsing/group.mlt" part="1"/>

	<p>
	  The <code>group</code> signature accepts a list of basic
	  <code>Command.t</code> values and their corresponding names.
	  When executed, it looks for the appropriate subcommand from
	  the name list, and dispatches it to the right command
	  handler.</p>

	<p>
	  Let's build the outline of a calendar tool that does a few
	  operations over dates from the command line. We first need to
	  define a command that adds days to an input date and prints
	  the resulting date:</p>

	<link rel="import" href="code/command-line-parsing/cal_add_days.ml"/>

	<p>
	  Everything in this command should be familiar to you by
	  now. Once you've tested it and made sure it works, we can
	  define another new command that takes the difference of two
	  dates. However, instead of creating a new binary, we group
	  both operations as subcommands using
	  <code>Command.group</code>:</p>

	<link rel="import" href="code/command-line-parsing/cal_add_sub_days/cal_add_sub_days.ml"/>

	<p>
	  And that's all you really need to add subcommand support!
	  Let's build the example first in the usual way and inspect
	  the help output, which now reflects the subcommands we just
	  added.</p>
  <link rel="import" href="code/command-line-parsing/cal_add_sub_days/jbuild"/>
	<link rel="import" href="code/command-line-parsing/cal_add_sub_days/cal_add_sub_days.sh" part="build"/>

	<p>
	  We can invoke the two commands we just defined to verify
	  that they work and see the date parsing in action:</p>

	<link rel="import" href="code/command-line-parsing/cal_add_sub_days/cal_add_sub_days.sh" part="run"/>
      </section>

      <section id="advanced-control-over-parsing" data-type="sect1">
	<h1>Advanced Control over Parsing</h1>

	<p>
	  The functions for generating a specification may seem like
	  magic. In particular, even if you know how to use them, it's
	  not entirely clear how they work, and in particular, why the
	  types work out the way they do.

	  <idx id="CLPadv">command-line parsing/advanced control over</idx></p>

	<p>
	  Understanding the details of how these specifications fit
	  together becomes more useful as your command-line interfaces
	  get more complex. In particular, you may want to factor out
	  common functionality between specifications or interrupt the
	  parsing to perform special processing, such as requesting an
	  interactive passphrase from the user before proceeding. All
	  of this is helped by a deeper understanding of the Command
	  library.</p>

	<p>
	  In the following sections we'll explain the logic behind
	  the combinators we've already described and show you some new
	  combinators that let you use Command even more
	  effectively.</p>

	<section id="the-types-behind-command.spec" data-type="sect2">
          <h2>The Types Behind Command.Spec</h2>

          <p>
	    The Command module's safety relies on the
            specification's output values precisely matching the
            callback function which invokes the main program. In order
            to prevent any such mismatches, Command uses some
            interesting type machinery to guarantee they remain in
            sync. You don't have to understand this section to use the
            more advanced combinators, but it'll help you debug type
            errors as you use Command more.

	    <idx>callback function</idx>
	    <idx>debugging/Command mode</idx>
	    <idx>Command module</idx></p>

          <p>
	    The <code>Command.Spec.t</code> type looks deceptively
            simple: <code>('a, 'b) t</code>. You can think of
            <code>('a, 'b) t</code> here as a function of type <code>'a
              -&gt; 'b</code>, but embellished with information
            about:</p>

          <ul>
            <li>
              <p>
		How to parse the command line</p>
            </li>

            <li>
              <p>
		What the command does and how to call it</p>
            </li>

            <li>
              <p>
		How to autocomplete a partial command line</p>
            </li>
          </ul>

          <p>
	    The type of a specification transforms a <code>'a</code>
            to a <code>'b</code> value. For instance, a value of
            <code>Spec.t</code> might have type <code>(arg1 -&gt; ...
              -&gt; argN -&gt; 'r, 'r) Spec.t</code>.</p>

          <p>
	    Such a value transforms a main function of type
            <code>arg1 -&gt; ... -&gt; argN -&gt; 'r</code> by
            supplying all the argument values, leaving a main function
            that returns a value of type <code>'r</code>. Let's look at
            some examples of specs, and their types:</p>

          <link rel="import" href="code/command-line-parsing/command_types.mlt" part="1"/>

          <p>
	    The empty specification is simple, as it doesn't add any
            parameters to the callback type. The second example adds an
            <code>int</code> anonymous parameter that is reflected in
            the inferred type. One forms a command by combining a spec
            of type <code>('main, unit) Spec.t</code> with a function
            of type <code>'main</code>. The combinators we've shown so
            far incrementally build the type of <code>'main</code>
            according to the command-line parameters it expects, so the
            resulting type of <code>'main</code> is something like
            <code>arg1 -&gt; ... -&gt; argN -&gt; unit</code>.</p>

          <p>
	    The type of <code>Command.basic</code> should make more
            sense now:</p>

          <link rel="import" href="code/command-line-parsing/basic.mlt" part="1"/>

          <p>
	    The parameters to <code>Spec.t</code> are important
            here. They show that the callback function for a spec
            should consume identical arguments to the supplied
            <code>main</code> function, except for an additional
            <code>unit</code> argument. This final <code>unit</code> is
            there to make sure the callback is evaluated as a function,
            since if zero command-line arguments are specified (i.e.,
            <span class="keep-together"><code>Spec.empty</code></span>), the
            callback would otherwise have no arguments and be evaluated
            immediately. That's why you have to supply an additional
            <code>()</code> to the callback function in all the
            previous examples.</p>
	</section>

	<section id="composing-specification-fragments-together" data-type="sect2">
          <h2>Composing Specification Fragments Together</h2>

          <p>
	    If you want to factor out common command-line
            operations, the <code>++</code> operator will append two
            specifications together. Let's add some dummy verbosity and
            debug flags to our calendar application to illustrate
            this.</p>

          <link rel="import" href="code/command-line-parsing/cal_append.ml"/>

          <p>
	    The definitions of the specifications are very similar
            to the earlier example, except that they append a
            <code>common</code> parameter after each specification. We
            can supply these flags when defining the groups.</p>

          <link rel="import" href="code/command-line-parsing/cal_append.ml" part="1"/>

          <p>
	    Both of these flags will now be applied and passed to
            all the callback functions. This makes code refactoring a
            breeze by using the compiler to spot places where you use
            commands. Just add a parameter to the common definition,
            run the compiler, and fix type errors until everything
            works again.

	    <idx>refactoring</idx></p>

          <p>
	    For example, if we remove the <code>verbose</code> flag
            and recompile, we'll get this impressively long type
            error:</p>
          <link rel="import" href="code/command-line-parsing/cal_append_broken/jbuild"/>
          <link rel="import" href="code/command-line-parsing/cal_append_broken/build_cal_append_broken.errsh"/>

          <p>
	    While this does look scary, the key line to scan is the
            last one, where it's telling you that you have supplied too
            many arguments in the callback function (<code>unit -&gt;
              unit</code> versus <code>unit</code>). If you started with
            a working program and made this single change, you
            typically don't even need to read the type error, as the
            filename and location information is sufficient to make the
            obvious fix.</p>
	</section>

	<section id="prompting-for-interactive-input" data-type="sect2">
          <h2>Prompting for Interactive Input</h2>

          <p>
	    The <code>step</code> combinator lets you control the
            normal course of parsing by supplying a function that maps
            callback arguments to a new set of values. For instance,
            let's revisit our first calendar application that added a
            number of days onto a supplied base date:

	    <idx>interactive input/prompts for</idx></p>

          <link rel="import" href="code/command-line-parsing/cal_add_days.ml"/>

          <p>
	    This program requires you to specify both the
            <code>base</code> date and the number of <code>days</code>
            to add onto it. If <code>days</code> isn't supplied on the
            command line, an error is output. Now let's modify it to
            interactively prompt for a number of days if only the
            <code>base</code> date is supplied:</p>

          <link rel="import" href="code/command-line-parsing/cal_add_interactive/cal_add_interactive.ml"/>

          <p>
	    The <code>days</code> anonymous argument is now an
            optional integer in the spec, and we want to transform it
            into a nonoptional value before calling our
            <code>add_days</code> callback. The <code>step</code>
            combinator lets us perform this transformation by applying
            its supplied callback function first. In the example, the
            callback first checks if <code>days</code> is defined. If
            it's undefined, then it interactively reads an integer from
            the standard input.</p>

          <p>
	    The first <code>m</code> argument to the
            <code>step</code> callback is the next callback function in
            the chain. The transformation is completed by calling
            <code>m base days</code> to continue processing with the
            new values we've just calculated. The <code>days</code>
            value that is passed onto the next callback now has a
            nonoptional <code>int</code> type:</p>

          <link rel="import" href="code/command-line-parsing/cal_add_interactive/build_and_run_cal_add_interactive.sh"/>

          <p>
	    The transformation means that the <code>add_days</code>
            callback can just keep its original definition of
            <code>Date.t -&gt; int -&gt; unit</code>. The
            <code>step</code> function transformed the <code>int
              option</code> argument from the parsing into an
            <code>int</code> suitable for <code>add_days</code>. This
            transformation is explicitly represented in the type of the
            <code>step</code> return value:</p>

          <link rel="import" href="code/command-line-parsing/step.mlt" part="1"/>

          <p>
	    The first half of the <code>Spec.t</code> shows that the
            callback type is <code>Date.t -&gt; int</code>, whereas the
            resulting value expected from the next specification in the
            chain is a <code>Date.t -&gt; int option</code>.</p>
	</section>

	<section id="adding-labeled-arguments-to-callbacks" data-type="sect2">
          <h2>Adding Labeled Arguments to Callbacks</h2>

          <p>
	    The <code>step</code> chaining lets you control the
            types of your callbacks very easily. This can help you
            match existing interfaces or make things more explicit by
            adding labeled arguments:

	    <idx>callback function</idx>
	    <idx>arguments/labeled arguments</idx>
	    <idx>labeled arguments</idx></p>

          <link rel="import" href="code/command-line-parsing/cal_add_labels.ml"/>

          <p>
	    This <code>cal_add_labels</code> example goes back to
            our noninteractive calendar addition program, but the
            <code>add_days</code> main function now expects labeled
            arguments. The <code>step</code> <span class="keep-together">function</span> in the specification simply
            converts the default <code>base</code> and
            <code>days</code> arguments into a labeled function.</p>

          <p>
	    Labeled arguments are more verbose but can also help
            prevent errors with command-line arguments with similar
            types but different names and purposes. It's good form to
            use labels when you have a lot of otherwise anonymous
            <code>int</code> and <code>string</code> arguments.
            <a data-type="indexterm" data-startref="CLPadv">&nbsp;</a></p>
	</section>
      </section>

      <section id="command-line-auto-completion-with-bash" data-type="sect1">
	<h1>Command-Line Autocompletion with bash</h1>

	<p>
	  Modern UNIX shells usually have a tab-completion feature
	  to interactively help you figure out how to build a command
	  line. These work by pressing the Tab key in the middle of
	  typing a command, and seeing the options that pop up. You've
	  probably used this most often to find the files in the
	  current directory, but it can actually be extended for other
	  parts of the command, too.

	  <idx>tab-autocompletion</idx>
	  <idx>autocompletion</idx>
	  <idx>command-line parsing/autocompletion with bash</idx></p>

	<p>
	  The precise mechanism for autocompletion varies depending
	  on what shell you are using, but we'll assume you are using
	  the most common one: <span class="command"><em>bash</em></span>. This is the default
	  interactive shell on most Linux distributions and Mac OS X,
	  but you may need to switch to it on *BSD or Windows (when
	  using Cygwin). The rest of this section assumes that you're
	  using <span class="command"><em>bash</em></span>.

	  <idx>bash autocompletion</idx></p>

	<p>
	  Bash autocompletion isn't always installed by default, so
	  check your OS package manager to see if you have it
	  available.</p>

	<table>
          <thead>
            <tr>
              <th>Operating system</th>

              <th>Package manager</th>

              <th>Package</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>Debian Linux</td>

              <td><code>apt</code></td>

              <td><code>bash-completion</code></td>
            </tr>

            <tr>
              <td>Mac OS X</td>

              <td>Homebrew</td>

              <td><code>bash-completion</code></td>
            </tr>

            <tr>
              <td>FreeBSD</td>

              <td>Ports system</td>

              <td><em class="filename">/usr/ports/shells/bash-completion</em></td>
            </tr>
          </tbody>
	</table>

	<p>
	  Once <em>bash</em> completion is installed and configured,
	  check that it works by typing the <code>ssh</code> command
	  and pressing the Tab key. This should show you the list of
	  known hosts from your <em>~/.ssh/known_hosts</em> file. If it
	  lists some hosts that you've recently connected to, you can
	  continue on. If it lists the files in your current directory
	  instead, then check your OS documentation to configure
	  completion correctly.</p>

	<p>
	  One last bit of information you'll need to find is the
	  location of the <em class="filename">bash_completion.d</em>
	  directory. This is where all the shell fragments that contain
	  the completion logic are held. On Linux, this is often in
	  <em class="filename">/etc/bash_completion.d</em>, and in
	  Homebrew on Mac OS X, it would be <em class="filename">/usr/local/etc/bash_completion.d</em> by
	  default.</p>

	<section id="generating-completion-fragments-from-command" data-type="sect2">
          <h2>Generating Completion Fragments from Command</h2>

          <p>
	    The Command library has a declarative description of all
            the possible valid options, and it can use this information
            to generate a shell script that provides completion support
            for that command. To generate the fragment, just run the
            command with the
            <code>COMMAND_OUTPUT_INSTALLATION_BASH</code> environment
            variable set to any value.</p>

          <p>
	    For example, let's try it on our MD5 example from
            earlier, assuming that the binary is called <span class="command"><em>basic_md5_with_flags</em></span> in the
            current directory:</p>

          <link rel="import" href="code/command-line-parsing/basic_md5_with_flags/basic_md5_with_flags.sh" part="completion"/>

          <p>
	    Recall that we used the <code>Arg_type.file</code> to
            specify the argument type. This also supplies the
            completion logic so that you can just press Tab to complete
            files in your current directory.</p>
	</section>

	<section id="installing-the-completion-fragment" data-type="sect2">
          <h2>Installing the Completion Fragment</h2>

          <p>
	    You don't need to worry about what the preceding output
            script actually does (unless you have an unhealthy
            fascination with shell scripting internals, that is).
            Instead, redirect the output to a file in your current
            directory and source it into your current shell:</p>

          <link rel="import" href="code/command-line-parsing/cal_completion.rawsh"/>

          <p>
	    Command completion support works for flags and grouped
            commands and is very useful when building larger
            command-line interfaces. Don't forget to install the shell
            fragment into your
            global <em class="filename">bash_completion.d</em>
            directory if you want it to be loaded in all of your login
            shells.

	    <idx>completion handlers</idx></p>

          <div data-type="note">
            <h1>Installing a Generic Completion Handler</h1>

            <p>
	      Sadly, <span class="command"><em>bash</em></span>
              doesn't support installing a generic handler for all
              Command-based applications. This means you have to
              install the completion script for every application, but
              you should be able to automate this in the build and
              packaging system for your application.</p>

            <p>
	      It will help to check out how other applications
              install tab-completion scripts and follow their lead, as
              the details are very OS-specific.</p>
          </div>
	</section>
      </section>

      <section id="alternative-command-line-parsers" data-type="sect1">
	<h1>Alternative Command-Line Parsers</h1>

	<p>
	  This rounds up our tour of the Command library. This isn't
	  the only way to parse command-line arguments of course; there
	  are several alternatives available on OPAM. Three of the most
	  prominent ones follow:

	  <idx>Cmdliner</idx>
	  <idx>OCaml toolchain/ocaml-getopt</idx>
	  <idx>Arg module</idx>
	  <idx>command-line parsing/alternatives to Command library</idx>
	  <idx>OPAM package manager</idx></p>

	<dl>
          <dt>The <code>Arg</code> module</dt>

          <dd>
            <p>
	      The <code>Arg</code> module is from the OCaml standard
              library, which is used by the compiler itself to handle
              its command-line interface. Command is generally more
              featureful than Arg (mainly via support for subcommands,
              the <code>step</code> combinator to transform inputs, and
              help generation), but there's absolutely nothing wrong
              with using Arg either.</p>

            <p>
	      You can use the
              <code>Command.Spec.flags_of_args_exn</code> function to
              convert Arg specifications into ones compatible with
              Command. This is quite often used to help port older
              non-Core code into the Core standard library world.</p>
          </dd>

          <dt>
            <a href="https://forge.ocamlcore.org/projects/ocaml-getopt/">ocaml-getopt</a>
          </dt>

          <dd>
            <p>
	      <code>ocaml-getopt</code> provides the general
              command-line syntax of GNU <code>getopt</code> and
              <code>getopt_long</code>. The GNU conventions are widely
              used in the open source world, and this library lets your
              OCaml programs obey the same rules.</p>
          </dd>

          <dt>
            <a href="http://erratique.ch/software/cmdliner">Cmdliner</a>
          </dt>

          <dd>
            <p>
	      Cmdliner is a mix between the Command and Getopt
              libraries. It allows for the declarative definition of
              command-line interfaces but exposes a more
              <code>getopt</code>-like interface. It also automates the
              generation of UNIX man pages as part of the
              specification. Cmdliner is the parser used by OPAM to
              manage its command line.</p>
          </dd>
	</dl>
      </section>
    </section>
  </body>
</html>
