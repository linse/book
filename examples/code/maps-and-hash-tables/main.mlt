#silent true;;
#use "topfind";;
#thread;;
#require "core";;
#require "core.top";;
#require "ppx_jane";;
#silent false;;

[@@@part "1"];;
open Base;;
let digit_alist =
  [ 0, "zero"; 1, "one"; 2, "two"  ; 3, "three"; 4, "four"
  ; 5, "five"; 6, "six"; 7, "seven"; 8, "eight"; 9, "nine" ]
;;
[%%expect ocaml {|
val digit_alist : (int * string) list =
  [(0, "zero"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
   (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
|}];;

[@@@part "2"];;
List.Assoc.find ~equal:Int.equal digit_alist 6;;
[%%expect ocaml {|- : string option = Some "six"|}];;
List.Assoc.find ~equal:Int.equal digit_alist 22;;
[%%expect ocaml {|- : string option = None|}];;
List.Assoc.add ~equal:Int.equal digit_alist 0 "zilch";;
[%%expect ocaml {|
- : (int, string) Base__List.Assoc.t =
[(0, "zilch"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
 (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
|}];;

[@@@part "3"];;
let digit_map = Map.of_alist_exn (module Int) digit_alist;;
[%%expect ocaml {|val digit_map : (int, string, Int.comparator_witness) Map.t = <abstr>|}];;
Map.find digit_map 6;;
[%%expect ocaml {|- : string option = Some "six"|}];;
Map.find digit_map 22;;
[%%expect ocaml {|- : string option = None|}];;
Map.set digit_map 0 "zilch" |> Map.to_alist;;
[%%expect ocaml {|
- : (int * string) list =
[(0, "zilch"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
 (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
|}];;

[@@@part "3.1"];;
Map.of_alist_exn (module Int) [22, "three"; 22, "four"];;
[%%expect{|Exception: ("Map.of_alist_exn: duplicate key" 22).|}];;

[@@@part "cw.1"];;
[(3, "three")];;
[%%expect ocaml {|- : (int * string) list = [(3, "three")]|}];;
Map.singleton (module Int) 3 "three";;
[%%expect ocaml {|- : (int, string, Int.comparator_witness) Map.t = <abstr>|}];;

[@@@part "ck.1"];;
module Service_id = struct
  type t =
    { service_name: string
    ; region: string
    ; instance: int
    } [@@deriving sexp_of, compare]
end;;
[%%expect ocaml {|
module Service_id :
  sig
    type t = { service_name : string; region : string; instance : int; }
    val sexp_of_t : t -> Sexp.t
    val compare : t -> t -> int
  end
|}];;

[@@@part "ck.2"];;
Map.empty (module Service_id);;
[%%expect{|
Characters 18-28:
Error: Signature mismatch:
       ...
       The value `comparator' is required but not provided
       File "src/comparator.mli", line 21, characters 2-53:
         Expected declaration
       The type `comparator_witness' is required but not provided
       File "src/comparator.mli", line 20, characters 2-25:
         Expected declaration
|}];;

[@@@part "ck.3"];;
module Service_id_comparator = struct
  type t = Service_id.t
  include Comparator.Make(Service_id)
end;;
[%%expect ocaml {|
module Service_id_comparator :
  sig
    type t = Service_id.t
    type comparator_witness =
        Base__Comparator.Make(Service_id).comparator_witness
    val comparator : (t, comparator_witness) Comparator.t
  end
|}];;

[@@@part "ck.4"];;
Map.empty (module Service_id_comparator);;
[%%expect ocaml {|
- : (Service_id_comparator.t, 'a, Service_id_comparator.comparator_witness)
    Map.t
= <abstr>
|}];;

[@@@part "ck.5"];;
module Service_id = struct
  module T = struct
    type t =
      { service_name: string
      ; region: string
      ; instance: int
      } [@@deriving sexp_of, compare]
  end
  include T
  include Comparator.Make(T)
end;;
[%%expect ocaml {|
module Service_id :
  sig
    module T :
      sig
        type t = { service_name : string; region : string; instance : int; }
        val sexp_of_t : t -> Sexp.t
        val compare : t -> t -> int
      end
    type t =
      T.t = {
      service_name : string;
      region : string;
      instance : int;
    }
    val sexp_of_t : t -> Sexp.t
    val compare : t -> t -> int
    type comparator_witness = Base__Comparator.Make(T).comparator_witness
    val comparator : (t, comparator_witness) Comparator.t
  end
|}];;

Map.empty (module Service_id);;
[%%expect ocaml {|- : (Service_id.t, 'a, Service_id.comparator_witness) Map.t = <abstr>|}];;

[@@@part "ck.6"];;
module Service_id = struct
  module T = struct
    type t =
      { service_name: string
      ; region: string
      ; instance: int
      } [@@deriving sexp_of, compare]
  end
  include T
  include Comparable.Make(T)
end;;
[%%expect ocaml {|
module Service_id :
  sig
    module T :
      sig
        type t = { service_name : string; region : string; instance : int; }
        val sexp_of_t : t -> Sexp.t
        val compare : t -> t -> int
      end
    type t =
      T.t = {
      service_name : string;
      region : string;
      instance : int;
    }
    val sexp_of_t : t -> Sexp.t
    val ( >= ) : t -> t -> bool
    val ( <= ) : t -> t -> bool
    val ( = ) : t -> t -> bool
    val ( > ) : t -> t -> bool
    val ( < ) : t -> t -> bool
    val ( <> ) : t -> t -> bool
    val equal : t -> t -> bool
    val compare : t -> t -> int
    val min : t -> t -> t
...
  end
|}];;



[@@@part "7.old"];;
module Reverse = Comparator.Make(struct
    type t = string
    let sexp_of_t = String.sexp_of_t
    let t_of_sexp = String.t_of_sexp
    let compare x y = String.compare y x
  end);;
[%%expect ocaml {|
module Reverse :
  sig
    type comparator_witness
    val comparator : (string, comparator_witness) Comparator.t
  end
|}];;

[@@@part "8.old"];;
let alist = ["foo", 0; "snoo", 3];;
[%%expect ocaml {|val alist : (string * int) list = [("foo", 0); ("snoo", 3)]|}];;
let ord_map = Map.of_alist_exn ~comparator:String.comparator alist;;
[%%expect{|
Characters 43-60:
Error: The function applied to this argument has type
         ('a * 'b) list -> ('a, 'b, 'c) Map.t
This argument cannot be applied with label ~comparator
|}];;
let rev_map = Map.of_alist_exn ~comparator:Reverse.comparator alist;;
[%%expect{|
Characters 43-61:
Error: The function applied to this argument has type
         ('a * 'b) list -> ('a, 'b, 'c) Map.t
This argument cannot be applied with label ~comparator
|}];;

[@@@part "9.old"];;
Map.min_elt ord_map;;
[%%expect{|
Characters 12-19:
Error: Unbound value ord_map
|}];;
Map.min_elt rev_map;;
[%%expect{|
Characters 12-19:
Error: Unbound value rev_map
|}];;

[@@@part "dc.1"];;
Map.merge;;
[%%expect ocaml {|
- : ('k, 'v1, 'cmp) Map.t ->
    ('k, 'v2, 'cmp) Map.t ->
    f:(key:'k ->
       [ `Both of 'v1 * 'v2 | `Left of 'v1 | `Right of 'v2 ] -> 'v3 option) ->
    ('k, 'v3, 'cmp) Map.t
= <fun>
|}];;

[@@@part "dc.2"];;
module Rev_string = struct
  type t = string
  include Comparator.Make(struct
      include String
      let compare x y = String.compare y x
    end);;
end;;
[%%expect ocaml {|
module Rev_string :
  sig
    type t = string
    type comparator_witness
    val comparator : (t, comparator_witness) Comparator.t
  end
|}];;

[@@@part "dc.3"];;
Map.of_alist_exn (module String)
  ["a",1; "b", 2; "c", 3]
|> Map.min_elt;;
[%%expect ocaml {|- : (string * int) option = Some ("a", 1)|}];;

Map.of_alist_exn (module Rev_string)
  ["a",1; "b", 2; "c", 3]
|> Map.min_elt;;
[%%expect ocaml {|- : (string * int) option = Some ("c", 3)|}];;


[@@@part "dc.4"];;
Map.merge
  (Map.of_alist_exn (module Rev_string) ["a",1; "b", 2; "c", 3])
  (Map.of_alist_exn (module String) ["b",3; "c", 1])
  ~f:(fun ~key data ->
    match data with `Left x -> x | `Right x -> x | `Both (x,y) -> x + y);;
[%%expect{|
Characters 77-127:
Error: This expression has type
         (string, int, String.comparator_witness) Map.t
       but an expression was expected of type
         (string, int, Rev_string.comparator_witness) Map.t
       Type String.comparator_witness is not compatible with type
         Rev_string.comparator_witness 
|}];;

[@@@part "pc.1"];;
Core_kernel.Map.Poly.of_alist digit_alist;;
[%%expect ocaml {|
- : [ `Duplicate_key of int | `Ok of (int, string) Core_kernel.Map.Poly.t ] =
`Ok <abstr>
|}];;

[@@@part "14"];;
Map.of_alist_exn (Comparator.Poly.comparator digit_alist);;
[%%expect{|
Characters 18-44:
Error: This expression has type
         ('a, Comparator.Poly.comparator_witness) Comparator.t
       This is not a function; it cannot be applied.
|}];;
                  
[@@@part "15"];;
Map.Poly.of_alist_exn digit_alist;;
[%%expect{|
Characters 0-21:
Error: Unbound module Map.Poly
|}];;

[@@@part "16"];;
Map.symmetric_diff
  (Map.Poly.singleton 3 "three")
  (Int.Map.singleton  3 "four" )
;;
[%%expect{|
Characters 22-40:
Error: Unbound module Map.Poly
|}];;

[@@@part "17"];;
let dedup ~comparator l =
  List.fold l ~init:(Set.empty ~comparator) ~f:Set.add
  |> Set.to_list
;;
[%%expect{|
Characters 58-68:
Error: The function applied to this argument has type
         ('a, 'b) Set.comparator -> ('a, 'b) Set.t
This argument cannot be applied with label ~comparator
|}];;
dedup ~comparator:Int.comparator [8;3;2;3;7;8;10];;
[%%expect{|
Characters 0-5:
Error: Unbound value dedup
|}];;

[@@@part "18"];;
let s1 = Set.of_list (module Int) [1;2];;
[%%expect ocaml {|val s1 : (int, Int.comparator_witness) Set.t = <abstr>|}];;
let s2 = Set.of_list (module Int) [2;1];;
[%%expect ocaml {|val s2 : (int, Int.comparator_witness) Set.t = <abstr>|}];;

[@@@part "19"];;
Set.equal s1 s2;;
[%%expect ocaml {|- : bool = true|}];;

[@@@part "20"];;
s1 = s2;;
[%%expect{|
Characters 0-2:
Error: This expression has type (int, Int.comparator_witness) Set.t
       but an expression was expected of type int
|}];;

[@@@part "21"];;
Set.to_tree s1 = Set.to_tree s2;;
[%%expect{|
Characters 0-11:
Error: Unbound value Set.to_tree
|}];;

[@@@part "22"];;
module Foo_and_bar : sig
  type t = { foo: Set.M(Int).t; bar: string }
  include Comparable.S with type t := t
end = struct
  module T = struct
    type t = { foo: Set.M(Int).t; bar: string } [@@deriving sexp]
    let compare t1 t2 =
      let c = Set.compare_direct t1.foo t2.foo in
      if c <> 0 then c else String.compare t1.bar t2.bar
  end
  include T
  include Comparable.Make(T)
end;;
[%%expect ocaml {|
module Foo_and_bar :
  sig
    type t = { foo : Base.Set.M(Base.Int).t; bar : string; }
    val ( >= ) : t -> t -> bool
    val ( <= ) : t -> t -> bool
    val ( = ) : t -> t -> bool
    val ( > ) : t -> t -> bool
    val ( < ) : t -> t -> bool
    val ( <> ) : t -> t -> bool
    val equal : t -> t -> bool
    val compare : t -> t -> int
    val min : t -> t -> t
    val max : t -> t -> t
    val ascending : t -> t -> int
    val descending : t -> t -> int
    val between : t -> low:t -> high:t -> bool
    val clamp_exn : t -> min:t -> max:t -> t
    val clamp : t -> min:t -> max:t -> t Base__.Or_error.t
    type comparator_witness
    val comparator : (t, comparator_witness) Comparator.t
    val validate_lbound : min:t Core_kernel._maybe_bound -> t Validate.check
    val validate_ubound : max:t Core_kernel._maybe_bound -> t Validate.check
    val validate_bound :
      min:t Core_kernel._maybe_bound ->
      max:t Core_kernel._maybe_bound -> t Validate.check
  end
|}];;

[@@@part "23"];;
module Foo_and_bar : sig
  type t = { foo: Set.M(Int).t; bar: string }
  include Comparable.S with type t := t
end = struct
  module T = struct
    type t = { foo: Set.M(Int).t; bar: string } [@@deriving sexp, compare]
  end
  include T
  include Comparable.Make(T)
end;;
[%%expect ocaml {|
module Foo_and_bar :
  sig
    type t = { foo : Base.Set.M(Base.Int).t; bar : string; }
    val ( >= ) : t -> t -> bool
    val ( <= ) : t -> t -> bool
    val ( = ) : t -> t -> bool
    val ( > ) : t -> t -> bool
    val ( < ) : t -> t -> bool
    val ( <> ) : t -> t -> bool
    val equal : t -> t -> bool
    val compare : t -> t -> int
    val min : t -> t -> t
    val max : t -> t -> t
    val ascending : t -> t -> int
    val descending : t -> t -> int
    val between : t -> low:t -> high:t -> bool
    val clamp_exn : t -> min:t -> max:t -> t
    val clamp : t -> min:t -> max:t -> t Base__.Or_error.t
    type comparator_witness
    val comparator : (t, comparator_witness) Comparator.t
    val validate_lbound : min:t Core_kernel._maybe_bound -> t Validate.check
    val validate_ubound : max:t Core_kernel._maybe_bound -> t Validate.check
    val validate_bound :
      min:t Core_kernel._maybe_bound ->
      max:t Core_kernel._maybe_bound -> t Validate.check
  end
|}];;

[@@@part "24"];;
module Foo_and_bar : sig
  type t = { foo: int; bar: string }
  include Comparable.S with type t := t
end = struct
  module T = struct
    type t = { foo: int; bar: string } [@@deriving sexp]
  end
  include T
  include Comparable.Poly(T)
end;;
[%%expect ocaml {|
module Foo_and_bar :
  sig
    type t = { foo : int; bar : string; }
    val ( >= ) : t -> t -> bool
    val ( <= ) : t -> t -> bool
    val ( = ) : t -> t -> bool
    val ( > ) : t -> t -> bool
    val ( < ) : t -> t -> bool
    val ( <> ) : t -> t -> bool
    val equal : t -> t -> bool
    val compare : t -> t -> int
...
  end
|}];;

[@@@part "25"];;
let table = Hashtbl.create ~hashable:String.hashable ();;
[%%expect{|
Characters 37-52:
Error: The function applied to this argument has type
         ?growth_allowed:bool -> ?size:int -> unit -> ('a, 'b) Hashtbl.t
This argument cannot be applied with label ~hashable
|}];;
Hashtbl.set table ~key:"three" ~data:3;;
[%%expect{|
Characters 12-17:
Error: Unbound value table
|}];;
Hashtbl.find table "three";;
[%%expect{|
Characters 13-18:
Error: Unbound value table
|}];;

[@@@part "26"];;
let table = String.Table.create ();;
[%%expect{|
Characters 12-31:
Error: Unbound module String.Table
|}];;

[@@@part "27"];;
let table = Hashtbl.create ~hashable:Hashtbl.Poly.hashable ();;
[%%expect{|
Characters 37-58:
Error: The function applied to this argument has type
         ?growth_allowed:bool -> ?size:int -> unit -> ('a, 'b) Hashtbl.t
This argument cannot be applied with label ~hashable
|}];;

[@@@part "28"];;
let table = Hashtbl.Poly.create ();;
[%%expect ocaml {|val table : ('_weak1, '_weak2) Hashtbl.t = <abstr>|}];;

[@@@part "29"];;
Caml.Hashtbl.hash (List.range 0 9);;
[%%expect ocaml {|- : int = 209331808|}];;
Caml.Hashtbl.hash (List.range 0 10);;
[%%expect ocaml {|- : int = 182325193|}];;
Caml.Hashtbl.hash (List.range 0 11);;
[%%expect ocaml {|- : int = 182325193|}];;
Caml.Hashtbl.hash (List.range 0 100);;
[%%expect ocaml {|- : int = 182325193|}];;

[@@@part "30"];;
module Foo_and_bar : sig
  type t = { foo: int; bar: string }
  include Hashable.S with type t := t
end = struct
  module T = struct
    type t = { foo: int; bar: string } [@@deriving sexp, compare, hash]
  end
  include T
  include Hashable.Make(T)
end;;
[%%expect{|
Characters 233-246:
Error: Unbound module Hashable
Hint: Did you mean Hashtbl or Hashtbl?
|}];;
